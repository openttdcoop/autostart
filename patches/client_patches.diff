diff -r 76fc4bf1ce4b -r 9e821d4b10b8 config.lib
--- config.lib	Sun Apr 12 15:17:27 2009 +0000
+++ config.lib	Sun Apr 12 18:10:09 2009 +0200
@@ -868,7 +868,7 @@
 			log 1 "WARNING: in most cases it is not safe for network use"
 			log 1 "WARNING: USE WITH CAUTION!"
 
-			sleep 5
+		#	sleep 5
 		elif [ -f "$ROOT_DIR/version" ]; then
 			revision="`cat $ROOT_DIR/version`"
 
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 projects/openttd_vs80.vcproj
--- projects/openttd_vs80.vcproj	Sun Apr 12 15:17:27 2009 +0000
+++ projects/openttd_vs80.vcproj	Sun Apr 12 18:10:09 2009 +0200
@@ -740,6 +740,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\timelapse.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\vehicle.cpp"
 				>
 			</File>
@@ -1496,6 +1500,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\timelapse.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\timetable.h"
 				>
 			</File>
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 projects/openttd_vs90.vcproj
--- projects/openttd_vs90.vcproj	Sun Apr 12 15:17:27 2009 +0000
+++ projects/openttd_vs90.vcproj	Sun Apr 12 18:10:09 2009 +0200
@@ -737,6 +737,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\timelapse.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\vehicle.cpp"
 				>
 			</File>
@@ -1493,6 +1497,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\timelapse.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\timetable.h"
 				>
 			</File>
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 source.list
--- source.list	Sun Apr 12 15:17:27 2009 +0000
+++ source.list	Sun Apr 12 18:10:09 2009 +0200
@@ -95,6 +95,7 @@
 	thread_none.cpp
 #end
 tile_map.cpp
+timelapse.cpp
 #if WIN32
 #else
 	#if WINCE
@@ -304,6 +305,7 @@
 tile_type.h
 tilehighlight_func.h
 tilehighlight_type.h
+timelapse.h
 timetable.h
 toolbar_gui.h
 town.h
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/command.cpp
--- src/command.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/command.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -20,6 +20,7 @@
 #include "company_func.h"
 #include "company_base.h"
 #include "signal_func.h"
+#include "timelapse.h"
 
 #include "table/strings.h"
 
@@ -589,6 +590,8 @@
 #endif /* ENABLE_NETWORK */
 	DEBUG(desync, 1, "cmd: %08x; %08x; %1x; %06x; %08x; %08x; %04x; %s\n", _date, _date_fract, (int)_current_company, tile, p1, p2, cmd & ~CMD_NETWORK_COMMAND, text);
 
+	TimelapseCommandCheck();
+
 	/* update last build coordinate of company. */
 	if (tile != 0 && IsValidCompanyID(_current_company)) {
 		GetCompany(_current_company)->last_build_coordinate = tile;
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/date.cpp
--- src/date.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/date.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -15,6 +15,7 @@
 #include "vehicle_base.h"
 #include "debug.h"
 #include "rail_gui.h"
+#include "timelapse.h"
 #include "saveload/saveload.h"
 
 Year      _cur_year;   ///< Current year, starting at 0
@@ -230,6 +231,7 @@
 	if (_game_mode != GM_MENU) {
 		InvalidateWindowWidget(WC_STATUS_BAR, 0, 0);
 		EnginesDailyLoop();
+		TimelapseDailyCheck();
 	}
 
 	/* check if we entered a new month? */
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/economy.cpp
--- src/economy.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/economy.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -1427,6 +1427,8 @@
 		}
 	}
 
+	InvalidateWindow(WC_INDUSTRY_VIEW, i->index);
+
 	TriggerIndustry(i, INDUSTRY_TRIGGER_RECEIVED_CARGO);
 	StartStopIndustryTileAnimation(i, IAT_INDUSTRY_RECEIVED_CARGO);
 }
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/industry_cmd.cpp
--- src/industry_cmd.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/industry_cmd.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -456,6 +456,8 @@
 		}
 	}
 
+	if (moved_cargo) InvalidateWindow(WC_INDUSTRY_VIEW, i->index);
+
 	if (moved_cargo && !StartStopIndustryTileAnimation(i, IAT_INDUSTRY_DISTRIBUTES_CARGO)) {
 		uint newgfx = GetIndustryTileSpec(GetIndustryGfx(tile))->anim_production;
 
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/industry_gui.cpp
--- src/industry_gui.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/industry_gui.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -557,6 +557,43 @@
 			y += 10;
 		}
 
+		first = true;
+		for (uint j = 0; j < lengthof(i->produced_cargo_waiting); j++) {
+			if (i->produced_cargo[j] == CT_INVALID) continue;
+			if (first) {
+				if (has_accept) y += 10;
+				DrawString(2, this->widget[IVW_INFO].right, y, STR_INDUSTRY_PRODUCTION_THIS_MONTH, TC_FROMSTRING);
+				y += 10;
+				this->production_offset_y = y;
+				first = false;
+			}
+
+			SetDParam(0, i->produced_cargo[j]);
+			SetDParam(1, i->this_month_production[j]);
+			SetDParam(2, GetCargoSuffix(j + 3, CST_VIEW, i, i->type, ind));
+
+			SetDParam(3, i->this_month_production[j] == 0 ? 0 : (i->this_month_transported[j] * 100 / i->this_month_production[j]));
+			DrawString(4, this->widget[IVW_INFO].right, y, STR_482B_TRANSPORTED, TC_FROMSTRING);
+			y += 10;
+		}
+
+		first = true;
+		for (uint j = 0; j < lengthof(i->produced_cargo_waiting); j++) {
+			if (i->produced_cargo[j] == CT_INVALID) continue;
+			if (first) {
+				if (has_accept) y += 10;
+				DrawString(2, this->widget[IVW_INFO].right, y, STR_INDUSTRY_WAITING_CARGO, TC_FROMSTRING);
+				y += 10;
+				this->production_offset_y = y;
+				first = false;
+			}
+
+			SetDParam(0, i->produced_cargo[j]);
+			SetDParam(1, i->produced_cargo_waiting[j]);
+			DrawString(4, this->widget[IVW_INFO].right, y, STR_INDUSTRY_WAITING_CARGO_DETAIL, TC_FROMSTRING);
+			y += 10;
+		}
+
 		/* Get the extra message for the GUI */
 		if (HasBit(ind->callback_flags, CBM_IND_WINDOW_MORE_TEXT)) {
 			uint16 callback_res = GetIndustryCallback(CBID_INDUSTRY_WINDOW_MORE_TEXT, 0, 0, i, i->type, i->xy);
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/landscape.cpp
--- src/landscape.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/landscape.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -605,6 +605,23 @@
 	return _tile_type_procs[GetTileType(tile)]->clear_tile_proc(tile, flags);
 }
 
+bool ClearSingleTile(TileIndex tile, DoCommandFlag flags, Money & money, CommandCost & cost)
+{
+	CommandCost ret = DoCommand(tile, 0, 0, flags & ~DC_EXEC, CMD_LANDSCAPE_CLEAR);
+ 	if (CmdFailed(ret)) return true;
+
+ 	if (flags & DC_EXEC) {
+ 		money -= ret.GetCost();
+		if (ret.GetCost() > 0 && money < 0) {
+ 			_additional_cash_required = ret.GetCost();
+ 			return false;
+ 		}
+ 		DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
+ 	}
+ 	cost.AddCost(ret);
+ 	return true;
+}
+
 /** Clear a big piece of landscape
  * @param tile end tile of area dragging
  * @param p1 start tile of area dragging
@@ -615,45 +632,39 @@
 {
 	if (p1 >= MapSize()) return CMD_ERROR;
 
-	/* make sure sx,sy are smaller than ex,ey */
-	int ex = TileX(tile);
-	int ey = TileY(tile);
-	int sx = TileX(p1);
-	int sy = TileY(p1);
-	if (ex < sx) Swap(ex, sx);
-	if (ey < sy) Swap(ey, sy);
-
 	Money money = GetAvailableMoneyForCommand();
 	CommandCost cost(EXPENSES_CONSTRUCTION);
-	bool success = false;
 
-	for (int x = sx; x <= ex; ++x) {
-		for (int y = sy; y <= ey; ++y) {
-			CommandCost ret = DoCommand(TileXY(x, y), 0, 0, flags & ~DC_EXEC, CMD_LANDSCAPE_CLEAR);
-			if (CmdFailed(ret)) continue;
-			success = true;
+	if (p2 & ORIENTATION_DIAG) {
+ 		for (DiagIterator iter(tile, p1); iter != TileIterator::end; ++iter) {
+ 			if (!ClearSingleTile(*iter, flags, money, cost)) return cost;
+ 		}
+ 	}
+ 	if (p2 & ORIENTATION_ORTH){
+ 		for (OrthIterator iter(tile, p1); iter != TileIterator::end; ++iter) {
+ 			if (!ClearSingleTile(*iter, flags, money, cost)) return cost;
+ 		}
+ 	}
 
-			if (flags & DC_EXEC) {
-				money -= ret.GetCost();
-				if (ret.GetCost() > 0 && money < 0) {
-					_additional_cash_required = ret.GetCost();
-					return cost;
-				}
-				DoCommand(TileXY(x, y), 0, 0, flags, CMD_LANDSCAPE_CLEAR);
+ 	/* draw explosion animation... */
+	/* big explosion in 2 corners, or small explosion
+	 * for single tiles
+	 */
+	CreateEffectVehicleAbove(TileX(tile) * TILE_SIZE + TILE_SIZE
+		/ 2, TileY(tile) * TILE_SIZE + TILE_SIZE / 2,
+		2, tile == p1 ?
+		EV_EXPLOSION_SMALL :
+		EV_EXPLOSION_LARGE
+	 );
 
-				/* draw explosion animation... */
-				if ((x == sx || x == ex) && (y == sy || y == ey)) {
-					/* big explosion in each corner, or small explosion for single tiles */
-					CreateEffectVehicleAbove(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, 2,
-						sy == ey && sx == ex ? EV_EXPLOSION_SMALL : EV_EXPLOSION_LARGE
-					);
-				}
-			}
-			cost.AddCost(ret);
-		}
-	}
+ 	if (tile != p1) {
+ 		CreateEffectVehicleAbove(TileX(p1) * TILE_SIZE + TILE_SIZE
+			/ 2, TileY(p1) * TILE_SIZE + TILE_SIZE / 2, 2,
+			EV_EXPLOSION_LARGE
+ 		);
+ 	}
 
-	return (success) ? cost : CMD_ERROR;
+ 	return (cost.GetCost() == 0) ? CMD_ERROR : cost;
 }
 
 
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/lang/english.txt
--- src/lang/english.txt	Sun Apr 12 15:17:27 2009 +0000
+++ src/lang/english.txt	Sun Apr 12 18:10:09 2009 +0200
@@ -970,6 +970,7 @@
 STR_CONFIG_SETTING_AUTORENEW_MONEY                              :{LTBLUE}Autorenew minimum needed money for renew: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_ERRMSG_DURATION                              :{LTBLUE}Duration of error message: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_POPULATION_IN_LABEL                          :{LTBLUE}Show town population in the town name label: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_RATING_IN_LABEL								:{LTBLUE}Show town rating in the town name label: {ORANGE}{STRING1}
 
 STR_CONFIG_SETTING_LAND_GENERATOR                               :{LTBLUE}Land generator: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_LAND_GENERATOR_ORIGINAL                      :Original
@@ -1088,6 +1089,37 @@
 STR_CONFIG_SETTING_CYCLE_SIGNAL_NORMAL                          :Block signals only
 STR_CONFIG_SETTING_CYCLE_SIGNAL_PBS                             :Path signals only
 STR_CONFIG_SETTING_CYCLE_SIGNAL_ALL                             :All
+STR_CONFIG_SETTING_IMP_NEWSTATIONS_GUI                          :{LTBLUE}Enable previews for station building: {ORANGE}{STRING1}
+
+STR_CONFIG_SETTING_AUTOMATIC_SCREENSHOTS                        :{ORANGE}Automatic Screenshots
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN                            :{LTBLUE}Take giant screenshots: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_OFF                        :Off
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_DAYS                       :Every x days
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_COMMANDS                   :Every y commands
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_DAYS_COMMANDS              :Every x days and y commands
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_INTERVAL                   :{LTBLUE}Interval for automatic giant screenshots: {ORANGE}{STRING1} day(s)
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_NUM_COMMANDS               :{LTBLUE}Command limit for automatic giant screenshots: {ORANGE}{STRING1} commands
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_ZOOMLVL                    :{LTBLUE}Zoom level for automatic giant screenshots: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_ZOOMLVL_NORMAL             :Normal
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_ZOOMLVL_2X                 :2x
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_ZOOMLVL_4X                 :4x
+STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_ZOOMLVL_8X                 :8x
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN                            :{LTBLUE}Take local screenshots: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_OFF                        :Off
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_DAYS                       :Every x days
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_COMMANDS                   :Every y commands
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_DAYS_COMMANDS              :Every x days and y commands
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_TYPES                      :{LTBLUE}Local screenshots are taken at: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_TYPES_SIGNS                :Signs
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_TYPES_STATIONS             :Stations
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_TYPES_SIGNS_AND_STATIONS   :Signs and stations
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_INTERVAL                   :{LTBLUE}Interval for automatic local screenshots: {ORANGE}{STRING1} day(s)
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_NUM_COMMANDS               :{LTBLUE}Command limit for automatic local screenshots: {ORANGE}{STRING1} commands
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_ZOOMLVL                    :{LTBLUE}Zoom level for automatic local screenshots: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_ZOOMLVL_NORMAL             :Normal
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_ZOOMLVL_2X                 :2x
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_ZOOMLVL_4X                 :4x
+STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_ZOOMLVL_8X                 :8x
 
 STR_CONFIG_SETTING_TOWN_LAYOUT                                  :{LTBLUE}Road layout for new towns: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_TOWN_LAYOUT_DEFAULT                          :original
@@ -1673,8 +1705,8 @@
 
 ##id 0x2000
 STR_2000_TOWNS                                                  :{WHITE}Towns
-STR_TOWN_LABEL_POP                                              :{WHITE}{TOWN} ({COMMA})
-STR_TOWN_LABEL                                                  :{WHITE}{TOWN}
+STR_TOWN_LABEL_POP                                              :{TOWN} ({COMMA})
+STR_TOWN_LABEL                                                  :{TOWN}
 STR_TOWN_LABEL_TINY_BLACK                                       :{TINYFONT}{BLACK}{TOWN}
 STR_TOWN_LABEL_TINY_WHITE                                       :{TINYFONT}{WHITE}{TOWN}
 STR_2002                                                        :{TINYFONT}{BLACK}{SIGN}
@@ -1979,8 +2011,12 @@
 STR_4828_PRODUCES                                               :{BLACK}Produces: {YELLOW}{STRING}{STRING}, {STRING}{STRING}
 ############ range for produces ends
 
-STR_482A_PRODUCTION_LAST_MONTH                                  :{BLACK}Production last month:
+STR_482A_PRODUCTION_LAST_MONTH                                  :{BLACK}Production (cargo distributed) last month:
 STR_482B_TRANSPORTED                                            :{YELLOW}{CARGO}{STRING}{BLACK} ({COMMA}% transported)
+STR_INDUSTRY_PRODUCTION_THIS_MONTH                              :{BLACK}Production (cargo distributed) this month:
+STR_INDUSTRY_WAITING_CARGO                                      :{BLACK}Cargo waiting to be distributed:
+STR_INDUSTRY_WAITING_CARGO_DETAIL                               :{YELLOW}{CARGO}
+
 STR_482C_CENTER_THE_MAIN_VIEW_ON                                :{BLACK}Centre the main view on industry location
 STR_482D_NEW_UNDER_CONSTRUCTION                                 :{BLACK}{BIGFONT}New {STRING} under construction near {TOWN}!
 STR_482E_NEW_BEING_PLANTED_NEAR                                 :{BLACK}{BIGFONT}New {STRING} being planted near {TOWN}!
@@ -3113,6 +3149,7 @@
 STR_NEWGRF_TOGGLE_PALETTE_TIP                                   :{BLACK}Toggle the palette of the selected NewGRF.{}Do this when the graphics from this NewGRF look pink in-game
 STR_NEWGRF_SET_PARAMETERS                                       :{BLACK}Set parameters
 STR_NEWGRF_FILENAME                                             :{BLACK}Filename: {SILVER}{RAW_STRING}
+STR_NEWGRF_NAME                                                 :{BLACK}Name: {SILVER}{RAW_STRING}
 STR_NEWGRF_PALETTE                                              :{BLACK}Palette: {SILVER}{RAW_STRING}
 STR_NEWGRF_GRF_ID                                               :{BLACK}GRF ID: {SILVER}{RAW_STRING}
 STR_NEWGRF_MD5SUM                                               :{BLACK}MD5sum: {SILVER}{RAW_STRING}
@@ -3148,19 +3185,23 @@
 STR_NEWGRF_ADD_TIP                                              :{BLACK}Add a NewGRF file to the list
 STR_NEWGRF_REMOVE                                               :{BLACK}Remove
 STR_NEWGRF_REMOVE_TIP                                           :{BLACK}Remove the selected NewGRF file from the list
-STR_NEWGRF_MOVEUP                                               :{BLACK}Move Up
+STR_NEWGRF_JOINT_ADD                                            :{BLACK}>>
+STR_NEWGRF_JOINT_REMOVE                                         :{BLACK}<<
+STR_NEWGRF_TOGGLE_SHOW                                          :{BLACK}Disp. Mode
+STR_NEWGRF_TOGGLE_SHOW_TIP                                      :{BLACK}Toggles filtering of already selected grfs in the left list. Ctrl-click toggles show file names in stead of grf names.
 STR_NEWGRF_MOVEUP_TIP                                           :{BLACK}Move the selected NewGRF file up the list
-STR_NEWGRF_MOVEDOWN                                             :{BLACK}Move Down
+STR_NEWGRF_MOVEUP                                               :{BLACK}Up
+STR_NEWGRF_MOVEDOWN                                             :{BLACK}Down
 STR_NEWGRF_MOVEDOWN_TIP                                         :{BLACK}Move the selected NewGRF file down the list
 STR_NEWGRF_FILE_TIP                                             :{BLACK}A list of the NewGRF files that are installed. Click a file to change its parameters
 STR_NEWGRF_PARAMETER                                            :{BLACK}Parameters: {SILVER}{STRING1}
 STR_NEWGRF_PARAMETER_QUERY                                      :{BLACK}Enter NewGRF parameters
 STR_NEWGRF_NO_INFO                                              :{BLACK}No information available
 
-STR_NEWGRF_ADD_CAPTION                                          :{WHITE}Available NewGRF files
+STR_NEWGRF_ADD_CAPTION                                          :{WHITE}Available NewGRFs
 STR_NEWGRF_ADD_FILE                                             :{BLACK}Add to selection
 STR_NEWGRF_ADD_FILE_TIP                                         :{BLACK}Add the selected NewGRF file to your configuration
-STR_NEWGRF_RESCAN_FILES                                         :{BLACK}Rescan files
+STR_NEWGRF_RESCAN_FILES                                         :{BLACK}Rescan
 STR_NEWGRF_RESCAN_FILES_TIP                                     :{BLACK}Update the list of available NewGRF files
 STR_NEWGRF_DUPLICATE_GRFID                                      :{WHITE}Can't add file: duplicate GRF ID
 
@@ -3485,6 +3526,13 @@
 
 ########
 
+#### GUI list filter 
+STR_FILTER                                                      :{BLACK}Filter
+STR_FILTER_OSKTITLE                                             :{BLACK}Enter a filter string
+STR_FILTER_MATCH_CASE                                           :{BLACK}Match case
+STR_FILTER_CLEAR                                                :{BLACK}Clear filter
+########
+
 STR_FUND_NEW_INDUSTRY                                           :{BLACK}Fund
 STR_PROSPECT_NEW_INDUSTRY                                       :{BLACK}Prospect
 STR_BUILD_NEW_INDUSTRY                                          :{BLACK}Build
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/main_gui.cpp
--- src/main_gui.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/main_gui.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -26,6 +26,7 @@
 #include "toolbar_gui.h"
 #include "statusbar_gui.h"
 #include "tilehighlight_func.h"
+#include "gui.h"
 
 #include "network/network.h"
 #include "network/network_func.h"
@@ -306,6 +307,10 @@
 			case 'X':
 				ResetRestoreAllTransparency();
 				break;
+				
+			case 'G':
+				PlaceLandBlockInfo();
+				break;
 
 #ifdef ENABLE_NETWORK
 			case WKC_RETURN: case 'T': // smart chat; send to team if any, otherwise to all
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/map.cpp
--- src/map.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/map.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -327,3 +327,65 @@
 	*tile = INVALID_TILE;
 	return false;
 }
+
+const InvalidIterator TileIterator::end = InvalidIterator();
+
+OrthIterator::OrthIterator(TileIndex corner1, TileIndex corner2)
+{
+	/* coordinates of end and start points */
+	x_max = TileX(corner2);
+	y_max = TileY(corner2);
+	uint x_min = TileX(corner1);
+	uint y_min = TileY(corner1);
+	Init(x_min, y_min);
+}
+
+void OrthIterator::Init(uint x_min, uint y_min)
+{
+	/* make sure x_min, y_min are smaller than x_max, y_max
+	 */
+	if (x_max < x_min) Swap(x_max, x_min);
+	if (y_max < y_min) Swap(y_max, y_min);
+
+	current = TileXY(x_min, y_min);
+	w = x_max - x_min + 1;
+}
+
+OrthIterator::OrthIterator(TileIndex corner, int width, int height)
+{
+	uint x_min = TileX(corner);
+	uint y_min = TileY(corner);
+	x_max = x_min + width;
+	y_max = y_min + height;
+	Init(x_min, y_min);
+}
+
+DiagIterator::DiagIterator(TileIndex corner1, TileIndex corner2)
+{
+	int dist_x = TileX(corner1) - TileX(corner2);
+	int dist_y = TileY(corner1) - TileY(corner2);
+	a_max = dist_x + dist_y;
+	b_max = dist_y - dist_x;
+	base = corner2;
+	/* Unfortunately we can't find a new base and make all a and b positive because
+	 * the new base might be a "flattened" corner where there actually is no single
+	 * tile. If we try anyway the result is either inaccurate ("one off" half of the
+	 * time) or the code gets much more complex;
+	 *
+	 * We also need to increment here to have equality as marker for the end of a row or
+	 * column. Like that it's shorter than having another if/else in operator++
+	 */
+	if (a_max > 0) {
+		a_max++;
+	} else {
+		a_max--;
+	}
+	if (b_max > 0) {
+		b_max++;
+	} else {
+		b_max--;
+	}
+	b_cur = 0;
+	a_cur = 0;
+	if (OutsideMap()) operator++();
+}
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/map_func.h
--- src/map_func.h	Sun Apr 12 15:17:27 2009 +0000
+++ src/map_func.h	Sun Apr 12 18:10:09 2009 +0200
@@ -333,6 +333,186 @@
 			} while (++var, --w_cur != 0);                       \
 		} while (var += TileDiffXY(0, 1) - (w), --h_cur != 0); \
 	}
+
+/* a common base class for tile iterators could be done as follows. On the downside
+ * we'd need virtual methods which degrades performance.
+ */
+class InvalidIterator;
+class TileIterator {
+public:
+	static const InvalidIterator end;
+	virtual TileIterator & operator++() = 0;
+	virtual TileIndex operator*() const = 0;
+};
+
+
+class InvalidIterator : public TileIterator {
+	TileIterator & operator++() {return *this;}
+	TileIndex operator*() const {return INVALID_TILE;}
+};
+
+/**
+ * an iterator that lists all the tiles in an orthogonally arranged rectangle.
+ * Use operator++ to advance it and operator* to get the current tile.
+ */
+class OrthIterator : public TileIterator {
+public:
+
+	OrthIterator(TileIndex corner1, TileIndex corner2);
+
+	OrthIterator(TileIndex corner, int width, int height);
+
+	inline OrthIterator & operator++()
+	{
+		++current;
+		if(TileX(current) > x_max) {
+			current += TileDiffXY(0, 1) - (w);
+			if (TileY(current) > y_max) {
+				current = INVALID_TILE;
+			}
+		}
+		return *this;
+	}
+
+	inline TileIndex operator*() const {return current;}
+
+	/**
+	 * compare two iterators.
+	 * They are equal iff all their members are.
+	 */
+	inline bool operator==(const OrthIterator & other) const
+	{
+		return current == other.current && x_max == other.x_max &&
+			y_max == other.y_max && w == other.w;
+	}
+
+	inline bool operator!=(const OrthIterator & other) const
+	{
+		return !operator==(other);
+	}
+
+private:
+	void Init(uint x_min, uint y_min);
+	TileIndex current;
+	uint x_max, y_max;
+	uint w;
+
+	friend bool operator==(const OrthIterator & it1, const InvalidIterator & it2);
+};
+
+inline bool operator==(const OrthIterator & it1, const InvalidIterator & it2)
+{
+	return it1.current == INVALID_TILE;
+}
+
+inline bool operator==(const InvalidIterator & it1, const OrthIterator & it2)
+{
+	return it2 == it1;
+}
+
+inline bool operator!=(const OrthIterator & it1, const InvalidIterator & it2)
+{
+	return !(it1 == it2);
+}
+
+inline bool operator!=(const InvalidIterator & it1, const OrthIterator & it2)
+{
+	return !(it2 == it1);
+}
+
+
+/**
+ * an iterator that lists all the tiles in an diagonally arranged rectangle.
+ * Use operator++ to advance it and operator* to get the current tile.
+ */
+class DiagIterator : public TileIterator {
+public:
+	/* a and b are coordinates in a rotated coordinate system.
+	 * base, a_max and b_max form a rectangle in a diagonal coordinate system.
+	 * a_max counts the number of diagonals in one direction, b_max in the other.
+	 * However with this method you only count half the squares. Compare with a
+	 * check board with alternating black and white squares. You only count one
+	 * color. That is why we count double the amount of rows and columns and
+	 * divide by 2 when translating the coordinates back.
+	 */
+
+	DiagIterator(TileIndex corner1, TileIndex corner2);
+
+	inline TileIterator & operator++()
+	{
+		do {
+			if (a_max > 0) {
+				++a_cur;
+			} else {
+				--a_cur;
+			}
+			if(a_cur == a_max) {
+				a_cur = 0;
+				if (b_max > 0) {
+					++b_cur;
+				} else {
+					--b_cur;
+				}
+			}
+		} while (OutsideMap() && b_max != b_cur);
+		return *this;
+	}
+
+	inline TileIndex operator*() const
+	{
+		return base + TileDiffXY((a_cur - b_cur) / 2, (b_cur + a_cur) / 2);
+	}
+
+	/**
+	 * compare two iterators.
+	 * They are equal iff all their members are.
+	 */
+	inline bool operator==(const DiagIterator & other) const
+	{
+		return base == other.base && b_cur == other.b_cur &&
+			b_max == other.b_max && a_cur == other.a_cur && a_max == other.a_max;
+	}
+
+	inline bool operator!=(const DiagIterator & other) const
+	{
+		return !operator==(other);
+	}
+
+private:
+	inline bool OutsideMap() const
+	{
+		TileIndex tile = base + TileDiffXY((a_cur - b_cur) / 2, (b_cur + a_cur) / 2);
+		return TileX(tile) >= MapSizeX() || TileY(tile) >= MapSizeY();
+	}
+
+	TileIndex base;
+	int a_cur, b_cur;
+	int a_max, b_max;
+
+	friend bool operator==(const DiagIterator & it1, const InvalidIterator & it2);
+};
+
+inline bool operator==(const DiagIterator & it1, const InvalidIterator & it2)
+{
+	return it1.b_cur == it1.b_max;
+}
+
+inline bool operator==(const InvalidIterator & it1, const DiagIterator & it2)
+{
+	return it2 == it1;
+}
+
+inline bool operator!=(const DiagIterator & it1, const InvalidIterator & it2)
+{
+	return !(it1 == it2);
+}
+
+inline bool operator!=(const InvalidIterator & it1, const DiagIterator & it2)
+{
+	return !(it2 == it1);
+}
+
+
 /**
  * Convert a DiagDirection to a TileIndexDiff
  *
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/map_type.h
--- src/map_type.h	Sun Apr 12 15:17:27 2009 +0000
+++ src/map_type.h	Sun Apr 12 18:10:09 2009 +0200
@@ -62,4 +62,17 @@
  */
 #define STRAIGHT_TRACK_LENGTH 7071/10000
 
+/**
+ * argument for CmdLevelLand describing what to do
+ */
+typedef enum {
+	LEVEL_LOWER	= 0x1,
+	LEVEL_RAISE	= 0x2,
+} LevelMode;
+
+typedef enum {
+	ORIENTATION_DIAG = 0x4,
+	ORIENTATION_ORTH = 0x8,
+} Orientation;
+
 #endif /* MAP_TYPE_H */
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/mixer.cpp
--- src/mixer.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/mixer.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -25,7 +25,7 @@
 	uint flags;
 };
 
-static MixerChannel _channels[8];
+static MixerChannel _channels[64];
 static uint32 _play_rate;
 
 /**
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/network/network_client.cpp
--- src/network/network_client.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/network/network_client.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -514,9 +514,15 @@
 			_password_game_seed = p->Recv_uint32();
 			p->Recv_string(_password_server_unique_id, sizeof(_password_server_unique_id));
 			if (MY_CLIENT->HasClientQuit()) return NETWORK_RECV_STATUS_MALFORMED_PACKET;
-
-		case NETWORK_GAME_PASSWORD:
-			ShowNetworkNeedPassword(type);
+	
+			if (_company_pw != NULL) _login_pw = _company_pw;
+			case NETWORK_GAME_PASSWORD:
+				if (_login_pw == NULL) {
+					ShowNetworkNeedPassword(type);
+				} else {
+					SEND_COMMAND(PACKET_CLIENT_PASSWORD)(type, _login_pw);
+					_login_pw = NULL;
+				}
 			return NETWORK_RECV_STATUS_OKAY;
 
 		default: return NETWORK_RECV_STATUS_MALFORMED_PACKET;
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/network/network_internal.h
--- src/network/network_internal.h	Sun Apr 12 15:17:27 2009 +0000
+++ src/network/network_internal.h	Sun Apr 12 18:10:09 2009 +0200
@@ -123,6 +123,9 @@
 
 void NetworkTCPQueryServer(NetworkAddress address);
 
+extern char *_login_pw;                      // login password from -p argument
+extern char *_company_pw;                    // company password from -P argument
+
 void GetBindAddresses(NetworkAddressList *addresses, uint16 port);
 void NetworkAddServer(const char *b);
 void NetworkRebuildHostList();
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/newgrf_gui.cpp
--- src/newgrf_gui.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/newgrf_gui.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -11,6 +11,7 @@
 #include "window_func.h"
 #include "string_func.h"
 #include "gfx_func.h"
+#include "tilehighlight_func.h"
 #include "gamelog.h"
 #include "settings_func.h"
 #include "widgets/dropdown_type.h"
@@ -45,7 +46,7 @@
 }
 
 
-static void ShowNewGRFInfo(const GRFConfig *c, uint x, uint y, uint w, uint bottom, bool show_params)
+static void ShowNewGRFInfo(const GRFConfig *c, uint x, uint y, uint w, uint bottom, bool show_params, bool show_filenames)
 {
 	char buff[256];
 
@@ -72,8 +73,8 @@
 
 	/* Draw filename or not if it is not known (GRF sent over internet) */
 	if (c->filename != NULL) {
-		SetDParamStr(0, c->filename);
-		y = DrawStringMultiLine(x, x + w, y, bottom, STR_NEWGRF_FILENAME);
+		SetDParamStr(0, (show_filenames) ? c->name : c->filename);
+		y = DrawStringMultiLine(x, x + w, y, bottom, (show_filenames) ? STR_NEWGRF_NAME : STR_NEWGRF_FILENAME);
 	}
 
 	/* Prepare and draw GRF ID */
@@ -117,150 +118,6 @@
 	}
 }
 
-
-/**
- * Window for adding NewGRF files
- */
-struct NewGRFAddWindow : public Window {
-	/* Names of the add a newgrf window widgets */
-	enum AddNewGRFWindowWidgets {
-		ANGRFW_CLOSEBOX = 0,
-		ANGRFW_CAPTION,
-		ANGRFW_BACKGROUND,
-		ANGRFW_GRF_LIST,
-		ANGRFW_SCROLLBAR,
-		ANGRFW_GRF_INFO,
-		ANGRFW_ADD,
-		ANGRFW_RESCAN,
-		ANGRFW_RESIZE,
-	};
-
-	GRFConfig **list;
-	const GRFConfig *sel;
-
-	NewGRFAddWindow(const WindowDesc *desc, GRFConfig **list) : Window(desc, 0)
-	{
-		this->list = list;
-		this->resize.step_height = 10;
-
-		this->FindWindowPlacementAndResize(desc);
-	}
-
-	virtual void OnPaint()
-	{
-		const GRFConfig *c;
-		const Widget *wl = &this->widget[ANGRFW_GRF_LIST];
-		int n = 0;
-
-		/* Count the number of GRFs */
-		for (c = _all_grfs; c != NULL; c = c->next) n++;
-
-		this->vscroll.cap = (wl->bottom - wl->top) / 10;
-		SetVScrollCount(this, n);
-
-		this->SetWidgetDisabledState(ANGRFW_ADD, this->sel == NULL || this->sel->IsOpenTTDBaseGRF());
-		this->DrawWidgets();
-
-		GfxFillRect(wl->left + 1, wl->top + 1, wl->right, wl->bottom, 0xD7);
-
-		uint y = wl->top + 1;
-		for (c = _all_grfs, n = 0; c != NULL && n < (this->vscroll.pos + this->vscroll.cap); c = c->next, n++) {
-			if (n >= this->vscroll.pos) {
-				bool h = c == this->sel;
-				const char *text = (c->name != NULL && !StrEmpty(c->name)) ? c->name : c->filename;
-
-				/* Draw selection background */
-				if (h) GfxFillRect(3, y, this->width - 15, y + 9, 156);
-				DrawString(4, this->width - 22, y, text, h ? TC_WHITE : TC_ORANGE);
-				y += 10;
-			}
-		}
-
-		if (this->sel != NULL) {
-			const Widget *wi = &this->widget[ANGRFW_GRF_INFO];
-			ShowNewGRFInfo(this->sel, wi->left + 2, wi->top + 2, wi->right - wi->left - 2, wi->bottom, false);
-		}
-	}
-
-	virtual void OnDoubleClick(Point pt, int widget)
-	{
-		if (widget == ANGRFW_GRF_LIST) this->OnClick(pt, ANGRFW_ADD);
-	}
-
-	virtual void OnClick(Point pt, int widget)
-	{
-		switch (widget) {
-			case ANGRFW_GRF_LIST: {
-				/* Get row... */
-				const GRFConfig *c;
-				uint i = (pt.y - this->widget[ANGRFW_GRF_LIST].top) / 10 + this->vscroll.pos;
-
-				for (c = _all_grfs; c != NULL && i > 0; c = c->next, i--) {}
-				this->sel = c;
-				this->SetDirty();
-				break;
-			}
-
-			case ANGRFW_ADD: // Add selection to list
-				if (this->sel != NULL) {
-					const GRFConfig *src = this->sel;
-					GRFConfig **list;
-
-					/* Find last entry in the list, checking for duplicate grfid on the way */
-					for (list = this->list; *list != NULL; list = &(*list)->next) {
-						if ((*list)->grfid == src->grfid) {
-							ShowErrorMessage(INVALID_STRING_ID, STR_NEWGRF_DUPLICATE_GRFID, 0, 0);
-							return;
-						}
-					}
-
-					/* Copy GRF details from scanned list */
-					GRFConfig *c = CallocT<GRFConfig>(1);
-					*c = *src;
-					c->filename = strdup(src->filename);
-					if (src->name      != NULL) c->name      = strdup(src->name);
-					if (src->info      != NULL) c->info      = strdup(src->info);
-					c->next = NULL;
-
-					/* Append GRF config to configuration list */
-					*list = c;
-
-					DeleteWindowByClass(WC_SAVELOAD);
-					InvalidateWindowData(WC_GAME_OPTIONS, 0);
-				}
-				break;
-
-			case ANGRFW_RESCAN: // Rescan list
-				this->sel = NULL;
-				ScanNewGRFFiles();
-				this->SetDirty();
-				break;
-		}
-	}
-};
-
-/* Widget definition for the add a newgrf window */
-static const Widget _newgrf_add_dlg_widgets[] = {
-{   WWT_CLOSEBOX,    RESIZE_NONE,  COLOUR_GREY,   0,  10,   0,  13, STR_00C5,                STR_018B_CLOSE_WINDOW },           // ANGRFW_CLOSEBOX
-{    WWT_CAPTION,   RESIZE_RIGHT,  COLOUR_GREY,  11, 306,   0,  13, STR_NEWGRF_ADD_CAPTION,  STR_018C_WINDOW_TITLE_DRAG_THIS }, // ANGRFW_CAPTION
-{      WWT_PANEL,      RESIZE_RB,  COLOUR_GREY,   0, 294,  14, 121, 0x0,                     STR_NULL },                        // ANGRFW_BACKGROUND
-{      WWT_INSET,      RESIZE_RB,  COLOUR_GREY,   2, 292,  16, 119, 0x0,                     STR_NULL },                        // ANGRFW_GRF_LIST
-{  WWT_SCROLLBAR,     RESIZE_LRB,  COLOUR_GREY, 295, 306,  14, 121, 0x0,                     STR_NULL },                        // ANGRFW_SCROLLBAR
-{      WWT_PANEL,     RESIZE_RTB,  COLOUR_GREY,   0, 306, 122, 224, 0x0,                     STR_NULL },                        // ANGRFW_GRF_INFO
-{ WWT_PUSHTXTBTN,     RESIZE_RTB,  COLOUR_GREY,   0, 146, 225, 236, STR_NEWGRF_ADD_FILE,     STR_NEWGRF_ADD_FILE_TIP },         // ANGRFW_ADD
-{ WWT_PUSHTXTBTN,    RESIZE_LRTB,  COLOUR_GREY, 147, 294, 225, 236, STR_NEWGRF_RESCAN_FILES, STR_NEWGRF_RESCAN_FILES_TIP },     // ANGRFW_RESCAN
-{  WWT_RESIZEBOX,    RESIZE_LRTB,  COLOUR_GREY, 295, 306, 225, 236, 0x0,                     STR_RESIZE_BUTTON },               // ANGRFW_RESIZE
-{   WIDGETS_END },
-};
-
-/* Window definition for the add a newgrf window */
-static const WindowDesc _newgrf_add_dlg_desc(
-	WDP_CENTER, WDP_CENTER, 307, 237, 307, 337,
-	WC_SAVELOAD, WC_NONE,
-	WDF_STD_TOOLTIPS | WDF_DEF_WIDGET | WDF_STD_BTN | WDF_UNCLICK_BUTTONS | WDF_RESIZABLE,
-	_newgrf_add_dlg_widgets
-);
-
 static GRFPresetList _grf_preset_list;
 
 class DropDownListPresetItem : public DropDownListItem {
@@ -283,45 +140,60 @@
 static void NewGRFConfirmationCallback(Window *w, bool confirmed);
 
 /**
- * Window for showing NewGRF files
+ * Combined NewGrf Window 
  */
 struct NewGRFWindow : public Window {
-	/* Names of the manage newgrfs window widgets */
-	enum ShowNewGRFStateWidgets {
-		SNGRFS_CLOSEBOX = 0,
+
+	/* Names of the window widgets */
+	enum NewGRFListWindowWidgets {
+		SNGRFS_CLOSE = 0,
 		SNGRFS_CAPTION,
-		SNGRFS_BACKGROUND1,
+		SNGRFS_EMPTY_PRESET,
 		SNGRFS_PRESET_LIST,
 		SNGRFS_PRESET_SAVE,
 		SNGRFS_PRESET_DELETE,
-		SNGRFS_BACKGROUND2,
-		SNGRFS_ADD,
+		SNGRFS_AVAILABLE_GRF_CAPTION,
+		SNGRFS_EMPTY_GRF_LIST,
+		SNGRFS_AVAILABLE_GRF_LIST,
+		SNGRFS_AVAILABLE_GRF_LIST_SCROLLBAR,
+		SNGRFS_NEWGRF_INFO,
+		SNGRFS_RESCAN_FILES,
+		SNGRFS_TOGGLE_SHOW_MODE,
+		SNGRFS_CONTENT_DOWNLOAD,
+		SNGRFS_EMPTY_MIDDLE,
+		SNGRFS_EMPTY_BOTTOM_MIDDLE,
+		SNGRFS_EMPTY_TOP_RIGHT,
+		SNGRFS_ADD_FILE,
 		SNGRFS_REMOVE,
 		SNGRFS_MOVE_UP,
 		SNGRFS_MOVE_DOWN,
 		SNGRFS_FILE_LIST,
-		SNGRFS_SCROLLBAR,
-		SNGRFS_NEWGRF_INFO,
+		SNGRFS_FILE_LIST_SCROLLBAR,
+		SNGRFS_TOGGLE_PALETTE,
 		SNGRFS_SET_PARAMETERS,
-		SNGRFS_TOGGLE_PALETTE,
 		SNGRFS_APPLY_CHANGES,
-		SNGRFS_CONTENT_DOWNLOAD,
-		SNGRFS_RESIZE,
 	};
-
-	GRFConfig **orig_list; ///< grf list the window is shown with
-	GRFConfig *list;       ///< temporary grf list to which changes are made
-	GRFConfig *sel;        ///< selected grf item
-	bool editable;         ///< is the window editable
-	bool show_params;      ///< are the grf-parameters shown in the info-panel
-	bool execute;          ///< on pressing 'apply changes' are grf changes applied immediately, or only list is updated
-	int query_widget;      ///< widget that opened a query
-	int preset;            ///< selected preset
+	
+	const GRFConfig *sel_l;
+	GRFConfig **orig_list;   ///< grf list the window is shown with
+	GRFConfig *list;         ///< temporary grf list to which changes are made
+	GRFConfig *sel_r;        ///< selected grf item
+	bool editable;           ///< is the window editable
+	bool show_params;        ///< are the grf-parameters shown in the info-panel
+	bool execute;            ///< on pressing 'apply changes' are grf changes applied immediately, or only list is updated
+	bool show_all;
+	bool show_file_names;
+	int query_widget;        ///< widget that opened a query
+	int preset;              ///< selected preset
 
 	NewGRFWindow(const WindowDesc *desc, bool editable, bool show_params, bool exec_changes, GRFConfig **config) : Window(desc, 0)
 	{
-		this->resize.step_height = 14;
-		this->sel         = NULL;
+		this->resize.step_height = 13;
+		this->resize.step_width = 8;
+		this->resize.height = this->height - 78;
+		this->resize.width  = this->width / 2 - 64;
+
+		this->sel_r       = NULL;
 		this->list        = NULL;
 		this->orig_list   = config;
 		this->editable    = editable;
@@ -336,6 +208,7 @@
 		this->SetupNewGRFWindow();
 	}
 
+
 	~NewGRFWindow()
 	{
 		if (this->editable && !this->execute) {
@@ -349,28 +222,14 @@
 		_grf_preset_list.Clear();
 	}
 
-	void SetupNewGRFWindow()
+	virtual void OnPaint()
 	{
 		const GRFConfig *c;
-		int i;
 
-		for (c = this->list, i = 0; c != NULL; c = c->next, i++) {}
+		int i, y;
+		int n = 0;
 
-		this->vscroll.cap = (this->widget[SNGRFS_FILE_LIST].bottom - this->widget[SNGRFS_FILE_LIST].top) / 14 + 1;
-		SetVScrollCount(this, i);
-
-		this->SetWidgetsDisabledState(!this->editable,
-			SNGRFS_PRESET_LIST,
-			SNGRFS_ADD,
-			SNGRFS_APPLY_CHANGES,
-			SNGRFS_TOGGLE_PALETTE,
-			WIDGET_LIST_END
-		);
-	}
-
-	virtual void OnPaint()
-	{
-		bool disable_all = this->sel == NULL || !this->editable;
+		bool disable_all = this->sel_r == NULL || !this->editable;
 
 		this->SetWidgetsDisabledState(disable_all,
 			SNGRFS_REMOVE,
@@ -378,14 +237,24 @@
 			SNGRFS_MOVE_DOWN,
 			WIDGET_LIST_END
 		);
+
+		this->SetWidgetsDisabledState(!this->editable,
+			SNGRFS_RESCAN_FILES,
+			SNGRFS_NEWGRF_INFO,
+			SNGRFS_AVAILABLE_GRF_LIST,
+			SNGRFS_APPLY_CHANGES,
+			WIDGET_LIST_END
+		);
+
+		this->SetWidgetDisabledState(SNGRFS_ADD_FILE, !this->editable || this->sel_l == NULL || this->sel_l->IsOpenTTDBaseGRF());
 		this->SetWidgetDisabledState(SNGRFS_SET_PARAMETERS, !this->show_params || disable_all);
 		this->SetWidgetDisabledState(SNGRFS_TOGGLE_PALETTE, disable_all);
 
 		if (!disable_all) {
 			/* All widgets are now enabled, so disable widgets we can't use */
-			if (this->sel == this->list)       this->DisableWidget(SNGRFS_MOVE_UP);
-			if (this->sel->next == NULL)       this->DisableWidget(SNGRFS_MOVE_DOWN);
-			if (this->sel->IsOpenTTDBaseGRF()) this->DisableWidget(SNGRFS_REMOVE);
+			if (this->sel_r == this->list) this->DisableWidget(SNGRFS_MOVE_UP);
+			if (this->sel_r->next == NULL) this->DisableWidget(SNGRFS_MOVE_DOWN);
+			if (this->sel_r->IsOpenTTDBaseGRF()) this->DisableWidget(SNGRFS_REMOVE);
 		}
 
 		if (this->preset == -1) {
@@ -413,12 +282,32 @@
 
 		this->DrawWidgets();
 
+		DrawString(this->widget[SNGRFS_AVAILABLE_GRF_CAPTION].left, this->widget[SNGRFS_AVAILABLE_GRF_CAPTION].right, 34, STR_NEWGRF_ADD_CAPTION, TC_WHITE,SA_CENTER);
+		GfxFillRect(this->widget[SNGRFS_AVAILABLE_GRF_LIST].left + 1, this->widget[SNGRFS_AVAILABLE_GRF_LIST].top + 1, this->widget[SNGRFS_AVAILABLE_GRF_LIST].right, this->widget[SNGRFS_AVAILABLE_GRF_LIST].bottom, 0xD7);
+
+		n = 0;
+		y = this->widget[SNGRFS_AVAILABLE_GRF_LIST].top + 2;
+		for (c = _all_grfs; c != NULL; c = c->next) {
+
+			if (IsInSelectedList(c->grfid)) continue;	
+			
+			if (n >= this->vscroll.pos && n < this->vscroll.pos + this->vscroll.cap) {
+				bool h = (c == this->sel_l);
+				const char *text = (c->name != NULL && !StrEmpty(c->name) && !this->show_file_names) ? c->name : c->filename;
+
+				/* Draw selection background */
+				if (h) GfxFillRect(3, y, this->widget[SNGRFS_AVAILABLE_GRF_LIST].right - 4, y + 9, 156);
+				DrawString(4, this->widget[SNGRFS_AVAILABLE_GRF_LIST].right - 7, y, text, h ? TC_WHITE : TC_ORANGE);
+				y += 10;
+			}
+			n++;
+		}
+
 		/* Draw NewGRF list */
-		int y = this->widget[SNGRFS_FILE_LIST].top;
-		int i = 0;
-		for (const GRFConfig *c = this->list; c != NULL; c = c->next, i++) {
-			if (i >= this->vscroll.pos && i < this->vscroll.pos + this->vscroll.cap) {
-				const char *text = (c->name != NULL && !StrEmpty(c->name)) ? c->name : c->filename;
+		y = this->widget[SNGRFS_FILE_LIST].top;
+		for (c = this->list, i = 0; c != NULL; c = c->next, i++) {
+			if (i >= this->vscroll2.pos && i < this->vscroll2.pos + this->vscroll2.cap) {
+				const char *text = (c->name != NULL && !StrEmpty(c->name) && !this->show_file_names) ? c->name : c->filename;
 				SpriteID pal;
 				byte txtoffset;
 
@@ -445,19 +334,104 @@
 					}
 				}
 
-				DrawSprite(SPR_SQUARE, pal, 5, y + 2);
-				if (c->error != NULL) DrawSprite(SPR_WARNING_SIGN, 0, 20, y + 2);
+				DrawSprite(SPR_SQUARE, pal, this->widget[SNGRFS_FILE_LIST].left + 9, y + 2);
+				if (c->error != NULL) DrawSprite(SPR_WARNING_SIGN, 0, this->widget[SNGRFS_FILE_LIST].left + 21, y + 2);
 				txtoffset = c->error != NULL ? 35 : 25;
-				DrawString(txtoffset, this->widget[SNGRFS_FILE_LIST].right - 2, y + 3, text, this->sel == c ? TC_WHITE : TC_BLACK);
-				y += 14;
+				DrawString(this->widget[SNGRFS_FILE_LIST].left + txtoffset,
+						this->widget[SNGRFS_FILE_LIST].right - 2 - txtoffset , y + 2,
+						text,
+						this->sel_r == c ? TC_WHITE : TC_BLACK);
+				y += 13;
 			}
 		}
 
-		if (this->sel != NULL) {
+		if (this->sel_r != NULL) {
 			/* Draw NewGRF file info */
 			const Widget *wi = &this->widget[SNGRFS_NEWGRF_INFO];
-			ShowNewGRFInfo(this->sel, wi->left + 2, wi->top + 2, wi->right - wi->left - 2, wi->bottom, this->show_params);
+			ShowNewGRFInfo(this->sel_r, wi->left + 2, wi->top + 2, wi->right - wi->left - 2, wi->bottom, this->show_params, this->show_file_names);
 		}
+
+		if (this->sel_l != NULL) {
+			const Widget *wi = &this->widget[SNGRFS_NEWGRF_INFO];
+			ShowNewGRFInfo(this->sel_l, wi->left + 2, wi->top + 2, wi->right - wi->left - 2, wi->bottom, false, this->show_file_names);
+		}
+
+	}
+
+	virtual void OnInvalidateData(int data)
+	{
+		switch (data) {
+			default: NOT_REACHED();
+			case 0:
+				this->preset = -1;
+				this->SetupNewGRFWindow();
+				break;
+		
+			case 1:
+				/* Search the list for items that are now found and mark them as such. */
+				for (GRFConfig *c = this->list; c != NULL; c = c->next) {
+					if (c->status != GCS_NOT_FOUND) continue;
+				
+					const GRFConfig *f = FindGRFConfig(c->grfid, c->md5sum);
+					if (f == NULL) continue;
+				
+					free(c->filename);
+					free(c->name);
+					free(c->info);
+				
+					c->filename  = f->filename == NULL ? NULL : strdup(f->filename);
+					c->name      = f->name == NULL ? NULL : strdup(f->name);;
+					c->info      = f->info == NULL ? NULL : strdup(f->info);;
+					c->status    = GCS_UNKNOWN;
+				}
+				break;
+		}
+		
+	}
+
+	virtual void OnDragMove(Point pt, int widget)
+	{
+		if (widget != SNGRFS_FILE_LIST) return;
+
+		GRFConfig **pc, *c, *source, *target;
+
+		if ((source = this->sel_r) == NULL) return;
+
+		uint i = (pt.y - this->widget[SNGRFS_FILE_LIST].top) / 13 + this->vscroll2.pos;
+		for (c = this->list; c != NULL && i > 0; c = c->next, i--)
+			if (c == source) i += 1;
+		target = c;
+		
+		if (target == source) return;
+
+		for (pc = &this->list; (c = *pc) != NULL; pc = &c->next) {
+			if (c == source)
+				*pc = c->next;
+			else if (c->next == source) {
+				c->next = c->next->next;
+			}
+		}
+
+		for (pc = &this->list; (c = *pc) != NULL; pc = &c->next) {
+			if (c == target) {
+				*pc = source;
+				source->next = target;
+			}
+			else if (c->next == target) {
+				c->next = source;
+				source->next = target;
+			}
+		}
+
+		this->SetDirty();
+	}
+
+	virtual void OnDoubleClick(Point pt, int widget)
+	{
+		if (widget == SNGRFS_AVAILABLE_GRF_LIST)
+			this->OnClick(pt, SNGRFS_ADD_FILE);
+		if (widget == SNGRFS_FILE_LIST && this->sel_r) 
+			this->OnClick(pt, SNGRFS_REMOVE);
 	}
 
 	virtual void OnClick(Point pt, int widget)
@@ -493,30 +467,97 @@
 				this->SetDirty();
 				break;
 
-			case SNGRFS_ADD: // Add GRF
-				DeleteWindowByClass(WC_SAVELOAD);
-				new NewGRFAddWindow(&_newgrf_add_dlg_desc, &this->list);
+			case SNGRFS_AVAILABLE_GRF_LIST: {
+				/* Get row... */
+				const GRFConfig *c;
+				uint i = ((pt.y) - this->widget[SNGRFS_AVAILABLE_GRF_LIST].top) / 10 + this->vscroll.pos;
+				
+				c = _all_grfs;
+				while (c && IsInSelectedList(c->grfid) && c->next) {
+					c = c->next;
+				}
+				while (c != NULL && i > 0)
+				{
+					c = c->next;
+					while (c != NULL && IsInSelectedList(c->grfid) && c->next) {
+						c = c->next;
+					}
+					--i;
+				}
+				if (c && IsInSelectedList(c->grfid)) c = NULL;
+				this->sel_l = c;
+				this->sel_r = NULL;
+				this->SetDirty();
+				break;
+			}
+
+			case SNGRFS_ADD_FILE: // Add selection to list
+				if (this->sel_l != NULL && this->editable) {
+					const GRFConfig *src = this->sel_l;
+					GRFConfig **list;
+
+					/* Find last entry in the list, checking for duplicate grfid on the way */
+					for (list = &this->list; *list != NULL; list = &(*list)->next) {
+						if ((*list)->grfid == src->grfid) {
+							ShowErrorMessage(INVALID_STRING_ID, STR_NEWGRF_DUPLICATE_GRFID, 0, 0);
+							return;
+						}
+					}
+
+					/* Copy GRF details from scanned list */
+					GRFConfig *c = CallocT<GRFConfig>(1);
+					*c = *src;
+					c->filename = strdup(src->filename);
+					if (src->name      != NULL) c->name      = strdup(src->name);
+					if (src->info      != NULL) c->info      = strdup(src->info);
+					c->next = NULL;
+
+					/* Append GRF config to configuration list */
+					*list = c;
+					this->sel_l = NULL;
+					this->preset = -1;
+					this->SetupNewGRFWindow();
+					this->SetDirty();
+				}
+				break;
+
+			case SNGRFS_RESCAN_FILES: // Rescan list
+				this->sel_l = NULL;
+				ScanNewGRFFiles();
+				this->SetDirty();
+				break;
+				
+			case SNGRFS_TOGGLE_SHOW_MODE: // Toggle show mode
+				if (_ctrl_pressed) {
+					this->show_file_names = !this->show_file_names;
+				}
+				else {
+					this->show_all = !this->show_all;
+				}
+
+				this->SetupNewGRFWindow(); // Adjust scroll bars
+				this->SetDirty();
 				break;
 
 			case SNGRFS_REMOVE: { // Remove GRF
 				GRFConfig **pc, *c, *newsel;
 
 				/* Choose the next GRF file to be the selected file */
-				newsel = this->sel->next;
+				newsel = this->sel_r->next;
 
 				for (pc = &this->list; (c = *pc) != NULL; pc = &c->next) {
 					/* If the new selection is empty (i.e. we're deleting the last item
 					 * in the list, pick the file just before the selected file */
-					if (newsel == NULL && c->next == this->sel) newsel = c;
+					if (newsel == NULL && c->next == this->sel_r) newsel = c;
 
-					if (c == this->sel) {
+					if (c == this->sel_r) {
 						*pc = c->next;
 						free(c);
 						break;
 					}
 				}
 
-				this->sel = newsel;
+				this->sel_r = newsel;
 				this->preset = -1;
 				this->SetupNewGRFWindow();
 				this->SetDirty();
@@ -525,13 +566,13 @@
 
 			case SNGRFS_MOVE_UP: { // Move GRF up
 				GRFConfig **pc, *c;
-				if (this->sel == NULL) break;
+				if (this->sel_r == NULL) break;
 
 				for (pc = &this->list; (c = *pc) != NULL; pc = &c->next) {
-					if (c->next == this->sel) {
-						c->next = this->sel->next;
-						this->sel->next = c;
-						*pc = this->sel;
+					if (c->next == this->sel_r) {
+						c->next = this->sel_r->next;
+						this->sel_r->next = c;
+						*pc = this->sel_r;
 						break;
 					}
 				}
@@ -542,10 +583,10 @@
 
 			case SNGRFS_MOVE_DOWN: { // Move GRF down
 				GRFConfig **pc, *c;
-				if (this->sel == NULL) break;
+				if (this->sel_r == NULL) break;
 
 				for (pc = &this->list; (c = *pc) != NULL; pc = &c->next) {
-					if (c == this->sel) {
+					if (c == this->sel_r) {
 						*pc = c->next;
 						c->next = c->next->next;
 						(*pc)->next = c;
@@ -559,11 +600,15 @@
 
 			case SNGRFS_FILE_LIST: { // Select a GRF
 				GRFConfig *c;
-				uint i = (pt.y - this->widget[SNGRFS_FILE_LIST].top) / 14 + this->vscroll.pos;
+				uint i = (pt.y - this->widget[SNGRFS_FILE_LIST].top) / 13 + this->vscroll2.pos;
 
-				for (c = this->list; c != NULL && i > 0; c = c->next, i--) {}
-				this->sel = c;
+				for (c = this->list; c != NULL && i > 0; c = c->next, i--) ;
+				this->sel_r = c;
+				this->sel_l = NULL;
 
+				/* Activate drag and drop */
+				SetObjectToPlaceWnd(SPR_CURSOR_MOUSE, PAL_NONE, VHM_DRAG, this);
+				
 				this->SetDirty();
 				break;
 			}
@@ -584,29 +629,29 @@
 				break;
 
 			case SNGRFS_SET_PARAMETERS: { // Edit parameters
-				if (this->sel == NULL) break;
+				if (this->sel_r == NULL) break;
 
 				this->query_widget = widget;
 				static char buff[512];
-				GRFBuildParamList(buff, this->sel, lastof(buff));
+				GRFBuildParamList(buff, this->sel_r, lastof(buff));
 				SetDParamStr(0, buff);
 				ShowQueryString(STR_JUST_RAW_STRING, STR_NEWGRF_PARAMETER_QUERY, 63, 250, this, CS_ALPHANUMERAL, QSF_NONE);
 				break;
 			}
 
-			case SNGRFS_TOGGLE_PALETTE:
-				if (this->sel != NULL) {
-					this->sel->windows_paletted ^= true;
+			case SNGRFS_TOGGLE_PALETTE: {
+				if (this->sel_r != NULL) {
+					this->sel_r->windows_paletted ^= true;
 					this->SetDirty();
 				}
 				break;
-
+				
 			case SNGRFS_CONTENT_DOWNLOAD:
 				if (!_network_available) {
 					ShowErrorMessage(INVALID_STRING_ID, STR_NETWORK_ERR_NOTAVAILABLE, 0, 0);
 				} else {
 #if defined(ENABLE_NETWORK)
-				/* Only show the things in the current list, or everything when nothing's selected */
+					/* Only show the things in the current list, or everything when nothing's selected */
 					ContentVector cv;
 					for (const GRFConfig *c = this->list; c != NULL; c = c->next) {
 						if (c->status != GCS_NOT_FOUND && !HasBit(c->flags, GCF_COMPATIBLE)) continue;
@@ -624,7 +669,9 @@
 #endif
 				}
 				break;
-
+			
+				
+			}
 		}
 	}
 
@@ -637,14 +684,14 @@
 			GRFConfig *c = LoadGRFPresetFromConfig(_grf_preset_list[index]);
 
 			if (c != NULL) {
-				this->sel = NULL;
+				this->sel_r = NULL;
 				ClearGRFConfigList(&this->list);
 				this->list = c;
 				this->preset = index;
 			}
 		}
 
-		this->sel = NULL;
+		this->sel_r = NULL;
 		this->SetupNewGRFWindow();
 		this->SetDirty();
 	}
@@ -671,7 +718,7 @@
 
 			case SNGRFS_SET_PARAMETERS: {
 				/* Parse our new "int list" */
-				GRFConfig *c = this->sel;
+				GRFConfig *c = this->sel_r;
 				c->num_params = parse_intlist(str, (int*)c->param, lengthof(c->param));
 
 				/* parse_intlist returns -1 on error */
@@ -686,80 +733,123 @@
 
 	virtual void OnResize(Point delta)
 	{
-		if (delta.x != 0) {
-			ResizeButtons(this, SNGRFS_ADD, SNGRFS_MOVE_DOWN);
-			ResizeButtons(this, SNGRFS_SET_PARAMETERS, SNGRFS_APPLY_CHANGES);
+		/* ASSUME: this->width, this->height already contains the new window size */
+
+		int left_column_width  = (this->width - 31) / 2 + 4;
+		int right_column_width = left_column_width - 7;
+
+		Widget *w = this->widget;
+		
+		w[SNGRFS_RESCAN_FILES].right =
+				(left_column_width / 2) - 1;
+
+		w[SNGRFS_TOGGLE_SHOW_MODE].left =
+				(left_column_width / 2);
+
+		w[SNGRFS_AVAILABLE_GRF_LIST].right = 
+				left_column_width - 14;
+
+		w[SNGRFS_AVAILABLE_GRF_LIST_SCROLLBAR].left =
+				left_column_width - 12;
+
+		w[SNGRFS_AVAILABLE_GRF_CAPTION].right =
+		w[SNGRFS_EMPTY_GRF_LIST].right =
+		w[SNGRFS_AVAILABLE_GRF_LIST_SCROLLBAR].right =
+		w[SNGRFS_TOGGLE_SHOW_MODE].right =
+		w[SNGRFS_CONTENT_DOWNLOAD].right = 
+				left_column_width - 1;
+
+		w[SNGRFS_EMPTY_MIDDLE].left =
+		w[SNGRFS_EMPTY_BOTTOM_MIDDLE].left =
+				left_column_width;
+
+		w[SNGRFS_ADD_FILE].left =
+		w[SNGRFS_REMOVE].left =
+				left_column_width + 5;
+
+		w[SNGRFS_ADD_FILE].right =
+		w[SNGRFS_REMOVE].right =
+				left_column_width + 25;
+
+		w[SNGRFS_EMPTY_MIDDLE].right =
+		w[SNGRFS_EMPTY_BOTTOM_MIDDLE].right =
+				left_column_width + 29;
+
+		int rightwin_start = left_column_width + 30;
+
+		w[SNGRFS_EMPTY_TOP_RIGHT].left =
+		w[SNGRFS_FILE_LIST].left =
+		w[SNGRFS_TOGGLE_PALETTE].left = 
+		w[SNGRFS_APPLY_CHANGES].left = 
+				rightwin_start;
+		
+		int button_width = (right_column_width < 198 ? 36 : 66);
+		int spacing = (right_column_width - 2 * button_width) / 3;
+		int pos     = rightwin_start + spacing;
+
+		w[SNGRFS_MOVE_UP].left    = pos; pos += button_width;
+		w[SNGRFS_MOVE_UP].right   = pos; pos += spacing;
+		w[SNGRFS_MOVE_DOWN].left  = pos; pos += button_width;
+		w[SNGRFS_MOVE_DOWN].right = pos;
+
+		spacing = right_column_width / 2;
+		w[SNGRFS_TOGGLE_PALETTE].right = rightwin_start + spacing - 1;
+		w[SNGRFS_SET_PARAMETERS].left  = rightwin_start + spacing;
+
+		int list_bottom;
+
+		if (this->height < 221) {
+			list_bottom = 104;
+		} else {
+			list_bottom = this->height - 106;
 		}
 
-		this->vscroll.cap += delta.y / 14;
-		this->widget[SNGRFS_FILE_LIST].data = (this->vscroll.cap << 8) + 1;
+		w[SNGRFS_EMPTY_GRF_LIST].bottom =
+		w[SNGRFS_AVAILABLE_GRF_LIST].bottom =
+		w[SNGRFS_AVAILABLE_GRF_LIST_SCROLLBAR].bottom =
+		w[SNGRFS_FILE_LIST].bottom =
+		w[SNGRFS_FILE_LIST_SCROLLBAR].bottom =
+		w[SNGRFS_EMPTY_MIDDLE].bottom =
+			list_bottom;
+
+		w[SNGRFS_NEWGRF_INFO].top = list_bottom + 1;
 
 		this->SetupNewGRFWindow();
 	}
+	
+	bool IsInSelectedList(uint32 grfid) {
+		if (this->show_all) return false;
+		const GRFConfig *ctemp;
+		for (ctemp = this->list; ctemp != NULL; ctemp = ctemp->next) {
+			if (grfid == ctemp->grfid) return true;
+		}
+		return false;
+	}
 
-	virtual void OnInvalidateData(int data)
+	void SetupNewGRFWindow()
 	{
-		switch (data) {
-			default: NOT_REACHED();
-			case 0:
-				this->preset = -1;
-				this->SetupNewGRFWindow();
-				break;
+		const GRFConfig *c;
+		uint16 n;
 
-			case 1:
-				/* Search the list for items that are now found and mark them as such. */
-				for (GRFConfig *c = this->list; c != NULL; c = c->next) {
-					if (c->status != GCS_NOT_FOUND) continue;
+		for (c = this->list, n = 0; c != NULL; c = c->next, n++) ;
 
-					const GRFConfig *f = FindGRFConfig(c->grfid, c->md5sum);
-					if (f == NULL) continue;
+		this->vscroll2.cap = (this->widget[SNGRFS_FILE_LIST].bottom - this->widget[SNGRFS_FILE_LIST].top) / 13;
 
-					free(c->filename);
-					free(c->name);
-					free(c->info);
+		this->widget[SNGRFS_FILE_LIST].data = (this->vscroll2.cap << 8) + 1;
+		SetVScroll2Count(this, n);
+		this->SetWidgetDisabledState(SNGRFS_APPLY_CHANGES, !this->editable);
 
-					c->filename  = f->filename == NULL ? NULL : strdup(f->filename);
-					c->name      = f->name == NULL ? NULL : strdup(f->name);;
-					c->info      = f->info == NULL ? NULL : strdup(f->info);;
-					c->status    = GCS_UNKNOWN;
-				}
-				break;
+		/* Count the number of GRFs */
+		for (c = _all_grfs, n = 0; c != NULL; c = c->next)
+		{
+			if (this->show_all || !IsInSelectedList(c->grfid)) n++;
 		}
+
+		this->vscroll.cap = (this->widget[SNGRFS_AVAILABLE_GRF_LIST].bottom - this->widget[SNGRFS_AVAILABLE_GRF_LIST].top) / 10;
+		SetVScrollCount(this, n);
 	}
 };
 
-/* Widget definition of the manage newgrfs window */
-static const Widget _newgrf_widgets[] = {
-{   WWT_CLOSEBOX,  RESIZE_NONE,  COLOUR_MAUVE,    0,  10,   0,  13, STR_00C5,                    STR_018B_CLOSE_WINDOW },            // SNGRFS_CLOSEBOX
-{    WWT_CAPTION, RESIZE_RIGHT,  COLOUR_MAUVE,   11, 299,   0,  13, STR_NEWGRF_SETTINGS_CAPTION, STR_018C_WINDOW_TITLE_DRAG_THIS },  // SNGRFS_CAPTION
-{      WWT_PANEL, RESIZE_RIGHT,  COLOUR_MAUVE,    0, 299,  14,  41, STR_NULL,                    STR_NULL },                         // SNGRFS_BACKGROUND1
-{   WWT_DROPDOWN, RESIZE_RIGHT,  COLOUR_YELLOW,  10, 103,  16,  27, STR_EMPTY,                   STR_NEWGRF_PRESET_LIST_TIP },       // SNGRFS_PRESET_LIST
-{ WWT_PUSHTXTBTN,    RESIZE_LR,  COLOUR_YELLOW, 104, 196,  16,  27, STR_NEWGRF_PRESET_SAVE,      STR_NEWGRF_PRESET_SAVE_TIP },       // SNGRFS_PRESET_SAVE
-{ WWT_PUSHTXTBTN,    RESIZE_LR,  COLOUR_YELLOW, 197, 289,  16,  27, STR_NEWGRF_PRESET_DELETE,    STR_NEWGRF_PRESET_DELETE_TIP },     // SNGRFS_PRESET_DELETE
-{      WWT_PANEL, RESIZE_RIGHT,  COLOUR_MAUVE,    0, 299,  30,  45, STR_NULL,                    STR_NULL },                         // SNGRFS_BACKGROUND
-{ WWT_PUSHTXTBTN,  RESIZE_NONE,  COLOUR_YELLOW,  10,  79,  32,  43, STR_NEWGRF_ADD,              STR_NEWGRF_ADD_TIP },               // SNGRFS_ADD
-{ WWT_PUSHTXTBTN,  RESIZE_NONE,  COLOUR_YELLOW,  80, 149,  32,  43, STR_NEWGRF_REMOVE,           STR_NEWGRF_REMOVE_TIP },            // SNGRFS_REMOVE
-{ WWT_PUSHTXTBTN,  RESIZE_NONE,  COLOUR_YELLOW, 150, 219,  32,  43, STR_NEWGRF_MOVEUP,           STR_NEWGRF_MOVEUP_TIP },            // SNGRFS_MOVE_UP
-{ WWT_PUSHTXTBTN, RESIZE_RIGHT,  COLOUR_YELLOW, 220, 289,  32,  43, STR_NEWGRF_MOVEDOWN,         STR_NEWGRF_MOVEDOWN_TIP },          // SNGRFS_MOVE_DOWN
-{     WWT_MATRIX,    RESIZE_RB,  COLOUR_MAUVE,    0, 287,  46, 115, 0x501,                       STR_NEWGRF_FILE_TIP },              // SNGRFS_FILE_LIST
-{  WWT_SCROLLBAR,   RESIZE_LRB,  COLOUR_MAUVE,  288, 299,  46, 115, 0x0,                         STR_0190_SCROLL_BAR_SCROLLS_LIST }, // SNGRFS_SCROLLBAR
-{      WWT_PANEL,   RESIZE_RTB,  COLOUR_MAUVE,    0, 299, 116, 238, STR_NULL,                    STR_NULL },                         // SNGRFS_NEWGRF_INFO
-{ WWT_PUSHTXTBTN,    RESIZE_TB,  COLOUR_MAUVE,    0,  99, 239, 250, STR_NEWGRF_SET_PARAMETERS,   STR_NULL },                         // SNGRFS_SET_PARAMETERS
-{ WWT_PUSHTXTBTN,   RESIZE_RTB,  COLOUR_MAUVE,  100, 199, 239, 250, STR_NEWGRF_TOGGLE_PALETTE,   STR_NEWGRF_TOGGLE_PALETTE_TIP },    // SNGRFS_TOGGLE_PALETTE
-{ WWT_PUSHTXTBTN,   RESIZE_RTB,  COLOUR_MAUVE,  200, 299, 239, 250, STR_NEWGRF_APPLY_CHANGES,    STR_NULL },                         // SNGRFS_APPLY_CHANGES
-{ WWT_PUSHTXTBTN,   RESIZE_RTB,  COLOUR_MAUVE,    0, 287, 251, 262, STR_CONTENT_INTRO_BUTTON,    STR_CONTENT_INTRO_BUTTON_TIP },     // SNGRFS_DOWNLOAD_CONTENT
-{  WWT_RESIZEBOX,  RESIZE_LRTB,  COLOUR_MAUVE,  288, 299, 251, 262, 0x0,                         STR_RESIZE_BUTTON },                // SNGRFS_RESIZE
-{ WIDGETS_END },
-};
-
-/* Window definition of the manage newgrfs window */
-static const WindowDesc _newgrf_desc(
-	WDP_CENTER, WDP_CENTER, 300, 263, 300, 263,
-	WC_GAME_OPTIONS, WC_NONE,
-	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS | WDF_RESIZABLE,
-	_newgrf_widgets
-);
-
 /** Callback function for the newgrf 'apply changes' confirmation window
  * @param w Window which is calling this callback
  * @param confirmed boolean value, true when yes was clicked, false otherwise
@@ -771,23 +861,64 @@
 		GRFConfig *c;
 		int i = 0;
 
-		GamelogStartAction(GLAT_GRF);
-		GamelogGRFUpdate(_grfconfig, nw->list); // log GRF changes
 		CopyGRFConfigList(nw->orig_list, nw->list, false);
 		ReloadNewGRFData();
-		GamelogStopAction();
 
 		/* Show new, updated list */
-		for (c = nw->list; c != NULL && c != nw->sel; c = c->next, i++) {}
+		for (c = nw->list; c != NULL && c != nw->sel_r; c = c->next, i++) ;
 		CopyGRFConfigList(&nw->list, *nw->orig_list, false);
-		for (c = nw->list; c != NULL && i > 0; c = c->next, i--) {}
-		nw->sel = c;
+		for (c = nw->list; c != NULL && i > 0; c = c->next, i--) ;
+		nw->sel_r = c;
 
 		w->SetDirty();
 	}
 }
 
+static const Widget _newgrf_widgets[] = {
+{   WWT_CLOSEBOX,  RESIZE_NONE,  COLOUR_MAUVE,   0,  10,   0,  13, STR_00C5,                    STR_018B_CLOSE_WINDOW },           // SNGRFS_CLOSE
+{    WWT_CAPTION, RESIZE_RIGHT,  COLOUR_MAUVE,  11, 599,   0,  13, STR_NEWGRF_SETTINGS_CAPTION, STR_018C_WINDOW_TITLE_DRAG_THIS }, // SNGRFS_CAPTION
+/* NewGRF Presets */
+{      WWT_PANEL, RESIZE_RIGHT,  COLOUR_MAUVE,   0, 599,  14,  29, STR_NULL,                    STR_NULL },                        // SNGRFS_EMPTY_PRESET
+{   WWT_DROPDOWN, RESIZE_RIGHT, COLOUR_YELLOW,  10, 403,  16,  27, STR_EMPTY,                   STR_NEWGRF_PRESET_LIST_TIP },      // SNGRFS_PRESET_LIST
+{ WWT_PUSHTXTBTN,    RESIZE_LR, COLOUR_YELLOW, 404, 496,  16,  27, STR_NEWGRF_PRESET_SAVE,      STR_NEWGRF_PRESET_SAVE_TIP },      // SNGRFS_PRESET_SAVE
+{ WWT_PUSHTXTBTN,    RESIZE_LR, COLOUR_YELLOW, 497, 587,  16,  27, STR_NEWGRF_PRESET_DELETE,    STR_NEWGRF_PRESET_DELETE_TIP },    // SNGRFS_PRESET_DELETE
+/* List of files */
+{      WWT_PANEL, RESIZE_RIGHT,  COLOUR_MAUVE,   0, 291,  30,  45, STR_NULL,                    STR_NULL },                        // SNGRFS_AVAILABLE_GRF_CAPTION
+{      WWT_PANEL,    RESIZE_RB,  COLOUR_MAUVE,   0, 279,  46, 137, STR_NULL,                    STR_NULL },                        // SNGRFS_EMPTY_GRF_LIST
+{      WWT_INSET,    RESIZE_RB,  COLOUR_MAUVE,   2, 277,  46, 137, STR_NULL,                    STR_NULL },                        // SNGRFS_AVAILABLE_GRF_LIST
+{  WWT_SCROLLBAR,   RESIZE_LRB,  COLOUR_MAUVE, 280, 291,  46, 137, STR_NULL,                    STR_0190_SCROLL_BAR_SCROLLS_LIST },// SNGRFS_AVAILABLE_GRF_LIST_SCROLLBAR
+/* NewGRF file info */
+{      WWT_PANEL,   RESIZE_RTB,  COLOUR_MAUVE,   0, 599, 138, 237, STR_NULL,                    STR_NULL },                        // SNGRFS_NEWGRF_INFO
+/* NewGRF file list buttons */
+{ WWT_PUSHTXTBTN,   RESIZE_RTB,  COLOUR_MAUVE,   0, 145, 238, 249, STR_NEWGRF_RESCAN_FILES,     STR_NEWGRF_RESCAN_FILES_TIP },     // SNGRFS_RESCAN_FILES
+{ WWT_PUSHTXTBTN,  RESIZE_LRTB,  COLOUR_MAUVE, 146, 291, 238, 249, STR_NEWGRF_TOGGLE_SHOW,      STR_NEWGRF_TOGGLE_SHOW_TIP },      // SNGRFS_TOGGLE_SHOW_MODE
+{ WWT_PUSHTXTBTN,   RESIZE_RTB,  COLOUR_MAUVE,   0, 291, 250, 261, STR_CONTENT_INTRO_BUTTON,    STR_CONTENT_INTRO_BUTTON_TIP },    // SNGRFS_DOWNLOAD_CONTENT
+/* Middle Panel */
+{      WWT_PANEL,   RESIZE_LRB,  COLOUR_MAUVE, 292, 321,  30, 137, STR_NULL,                    STR_NULL },                        // SNGRFS_EMPTY_MIDDLE
+{      WWT_PANEL,  RESIZE_LRTB,  COLOUR_MAUVE, 292, 321, 238, 261, STR_NULL,                    STR_NULL },                        // SNGRFS_EMPTY_BOTTOM_MIDDLE
+/* NewGRF file Add, Remove, Move up, Move down */
+{      WWT_PANEL,    RESIZE_LR,  COLOUR_MAUVE, 322, 599,  30,  45, STR_NULL,                    STR_NULL },                        // SNGRFS_EMPTY_TOP_RIGHT
+{ WWT_PUSHTXTBTN,    RESIZE_LR, COLOUR_YELLOW, 297, 316,  36,  58, STR_NEWGRF_JOINT_ADD,        STR_NEWGRF_ADD_TIP },              // SNGRFS_ADD_FILE
+{ WWT_PUSHTXTBTN,    RESIZE_LR, COLOUR_YELLOW, 297, 316,  66,  88, STR_NEWGRF_JOINT_REMOVE,     STR_NEWGRF_REMOVE_TIP },           // SNGRFS_REMOVE
+{ WWT_PUSHTXTBTN,    RESIZE_LR, COLOUR_YELLOW, 379, 445,  32,  43, STR_NEWGRF_MOVEUP,           STR_NEWGRF_MOVEUP_TIP },           // SNGRFS_MOVE_UP
+{ WWT_PUSHTXTBTN,    RESIZE_LR, COLOUR_YELLOW, 484, 550,  32,  43, STR_NEWGRF_MOVEDOWN,         STR_NEWGRF_MOVEDOWN_TIP },         // SNGRFS_MOVE_DOWN
+/* NewGRF file list */
+{     WWT_MATRIX,   RESIZE_LRB,  COLOUR_MAUVE, 322, 588,  46, 137, 0x501,                       STR_NEWGRF_FILE_TIP },             // SNGRFS_FILE_LIST
+{ WWT_SCROLL2BAR,   RESIZE_LRB,  COLOUR_MAUVE, 588, 599,  46, 137, STR_NULL,                    STR_0190_SCROLL_BAR_SCROLLS_LIST },// SNGRFS_FILE_LIST_SCROLLBAR
+/* Edit parameter and apply changes button... */
+{ WWT_PUSHTXTBTN,  RESIZE_LRTB,  COLOUR_MAUVE, 322, 458, 238, 249, STR_NEWGRF_TOGGLE_PALETTE,   STR_NEWGRF_TOGGLE_PALETTE_TIP },   // SNGRFS_TOGGLE_PALETTE
+{ WWT_PUSHTXTBTN,  RESIZE_LRTB,  COLOUR_MAUVE, 459, 599, 238, 249, STR_NEWGRF_SET_PARAMETERS,   STR_NULL },                        // SNGRFS_SET_PARAMETERS
+{ WWT_PUSHTXTBTN,  RESIZE_LRTB,  COLOUR_MAUVE, 322, 587, 250, 261, STR_NEWGRF_APPLY_CHANGES,    STR_NULL },                        // SNGRFS_APPLY_CHANGES
+{  WWT_RESIZEBOX,  RESIZE_LRTB,  COLOUR_MAUVE, 588, 599, 250, 261, STR_NULL,                    STR_RESIZE_BUTTON },
+{   WIDGETS_END },
+};
 
+static const WindowDesc _newgrf_desc(
+	WDP_CENTER, WDP_CENTER, 600, 262, 600, 262,
+	WC_GAME_OPTIONS, WC_NONE,
+	WDF_STD_TOOLTIPS | WDF_DEF_WIDGET | WDF_STD_BTN | WDF_UNCLICK_BUTTONS | WDF_RESIZABLE,
+	_newgrf_widgets
+);
 
 /** Setup the NewGRF gui
  * @param editable allow the user to make changes to the grfconfig in the window
@@ -798,5 +929,7 @@
 void ShowNewGRFSettings(bool editable, bool show_params, bool exec_changes, GRFConfig **config)
 {
 	DeleteWindowByClass(WC_GAME_OPTIONS);
+
 	new NewGRFWindow(&_newgrf_desc, editable, show_params, exec_changes, config);
 }
+
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/openttd.cpp
--- src/openttd.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/openttd.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -157,6 +157,8 @@
 		"  -G seed             = Set random seed\n"
 #if defined(ENABLE_NETWORK)
 		"  -n [ip:port#company]= Start networkgame\n"
+		"  -p password         = Join password\n"
+		"  -P password         = Company password\n"
 		"  -D [ip][:port]      = Start dedicated server\n"
 		"  -l ip[:port]        = Redirect DEBUG()\n"
 #if !defined(__MORPHOS__) && !defined(__AMIGA__) && !defined(WIN32)
@@ -379,6 +381,10 @@
 }
 
 byte _savegame_sort_order;
+#if defined(ENABLE_NETWORK)
+char *_login_pw = NULL;
+char *_company_pw = NULL;
+#endif /* ENABLE_NETWORK */
 #if defined(UNIX) && !defined(__MORPHOS__)
 extern void DedicatedFork();
 #endif
@@ -415,7 +421,7 @@
 	 *   a letter means: it accepts that param (e.g.: -h)
 	 *   a ':' behind it means: it need a param (e.g.: -m<driver>)
 	 *   a '::' behind it means: it can optional have a param (e.g.: -d<debug>) */
-	optformat = "m:s:v:b:hD::n::ei::I:t:d::r:g::G:c:xl:"
+	optformat = "m:s:v:b:hD::n::ei::I:t:d::r:g::G:c:xl:p:P:"
 #if !defined(__MORPHOS__) && !defined(__AMIGA__) && !defined(WIN32)
 		"f"
 #endif
@@ -460,6 +466,12 @@
 		case 'l':
 			debuglog_conn = mgo.opt;
 			break;
+		case 'p':
+			_login_pw = mgo.opt;
+			break;
+		case 'P':
+			_company_pw = mgo.opt;
+			break;
 #endif /* ENABLE_NETWORK */
 		case 'r': ParseResolution(&resolution, mgo.opt); break;
 		case 't': startyear = atoi(mgo.opt); break;
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/rail_gui.cpp
--- src/rail_gui.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/rail_gui.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -30,6 +30,10 @@
 #include "table/sprites.h"
 #include "table/strings.h"
 
+#include <vector>
+
+#define MAX_NEWGUI_STATIONS 10
+
 static RailType _cur_railtype;               ///< Rail type of the current build-rail toolbar.
 static bool _remove_button_clicked;          ///< Flag whether 'remove' toggle-button is currently enabled
 static DiagDirection _build_depot_direction; ///< Currently selected depot direction
@@ -42,13 +46,24 @@
 /* Map the setting: default_signal_type to the corresponding signal type */
 static const SignalType _default_signal_type[] = {SIGTYPE_NORMAL, SIGTYPE_PBS, SIGTYPE_PBS_ONEWAY};
 
+struct StationClass_Testing {
+		int result;
+		StringID string;
+};
+
+typedef std::vector<StationClass_Testing *> StationClasses;
+
 struct RailStationGUISettings {
 	Axis orientation;                 ///< Currently selected rail station orientation
 
 	bool newstations;                 ///< Are custom station definitions available?
+	bool imp_newstations;             ///< Use the improved newstations gui?
 	StationClassIDByte station_class; ///< Currently selected custom station class (if newstations is \c true )
 	byte station_type;                ///< Station type within the currently selected custom station class (if newstations is \c true )
 	byte station_count;               ///< Number of custom stations (if newstations is \c true )
+	byte station_class_count;
+	StationClasses station_classes;
+	Point window_size;                ///< Last window size
 };
 static RailStationGUISettings _railstation; ///< Settings of the station builder GUI
 
@@ -916,7 +931,14 @@
 
 		BRSW_NEWST_DROPDOWN,
 		BRSW_NEWST_LIST,
-		BRSW_NEWST_SCROLL
+		BRSW_NEWST_SCROLL,
+
+		BRSW_NEWGUI_LIST,
+		BRSW_NEWGUI_CLASS_SCROLL,
+
+		BRSW_NEWGUI_STATIONS_LIST,
+		BRSW_NEWGUI_STATION_SCROLL,
+		BRSW_NEWGUI_RESIZE,
 	};
 
 	/**
@@ -979,17 +1001,52 @@
 		this->SetWidgetLoweredState(BRSW_HIGHLIGHT_OFF, !_settings_client.gui.station_show_coverage);
 		this->SetWidgetLoweredState(BRSW_HIGHLIGHT_ON, _settings_client.gui.station_show_coverage);
 
-		this->FindWindowPlacementAndResize(desc);
-
 		_railstation.newstations = newstation;
+		_railstation.imp_newstations = _settings_client.gui.imp_newstations_gui;
 
 		if (newstation) {
 			_railstation.station_count = GetNumCustomStations(_railstation.station_class);
+			if (!_railstation.imp_newstations) {
+				int top = this->vscroll.count - this->vscroll.cap;
+				this->vscroll.count = _railstation.station_count;
+				this->vscroll.cap   = 5;
+				this->vscroll.pos   = Clamp(_railstation.station_type - 2, 0, top > 0 ? top : 0);
+			} else {
+				// If the window is being opened again refresh the station classes
+				if (!_railstation.station_classes.empty()) {
+					_railstation.station_classes.clear();
+					_railstation.station_class_count = 0;
+				}
 
-			this->vscroll.count = _railstation.station_count;
-			this->vscroll.cap   = 5;
-			this->vscroll.pos   = Clamp(_railstation.station_type - 2, 0, this->vscroll.count - this->vscroll.cap);
+				for(uint i = 0; i < GetNumStationClasses(); i++) {
+					if (i == STAT_CLASS_WAYP) continue;
+					_railstation.station_class_count++;
+					StationClass_Testing *station_class = new StationClass_Testing();
+					station_class->result = i;
+					station_class->string = GetStationClassName((StationClassID)i);
+					_railstation.station_classes.push_back(station_class);
+				}
+
+				this->resize.step_width  = 65;
+				this->resize.step_height = 48;
+
+				int top   = this->vscroll.count - this->vscroll.cap, top2 = this->vscroll2.count - this->vscroll2.cap;
+				int width = this->widget[BRSW_NEWGUI_STATIONS_LIST].data & 0xFF;
+
+				this->vscroll.cap    = 3;
+				this->vscroll.pos    = Clamp(_railstation.station_class, 0, top > 0 ? top : 0);
+				this->vscroll.count  = _railstation.station_class_count;
+
+				this->vscroll2.cap   = 5;
+				this->vscroll2.pos   = Clamp(_railstation.station_type / width, 0, top2 > 0 ? top2 : 0);
+				this->vscroll2.count = _railstation.station_count / width  + (_railstation.station_count % width > 0);
+			}
 		}
+
+		if (_railstation.window_size.x != 0)
+			this->FindWindowPlacementAndResize(_railstation.window_size.x, _railstation.window_size.y);
+		else
+			this->FindWindowPlacementAndResize(desc);
 	}
 
 	virtual ~BuildRailStationWindow()
@@ -1000,6 +1057,7 @@
 	virtual void OnPaint()
 	{
 		bool newstations = _railstation.newstations;
+		bool imp_newstations = _railstation.imp_newstations && newstations;
 		DrawPixelInfo tmp_dpi, *old_dpi;
 		const StationSpec *statspec = newstations ? GetCustomStationSpec(_railstation.station_class, _railstation.station_type) : NULL;
 
@@ -1032,7 +1090,9 @@
 		SetDParam(0, GetStationClassName(_railstation.station_class));
 		this->DrawWidgets();
 
-		int y_offset = newstations ? 90 : 0;
+		int y_offset  = newstations ? 90 : 0;
+		    //  260 is the default background height, 48 is 1 height-resize
+		    y_offset += imp_newstations ? this->widget[BRSW_BACKGROUND].bottom - 260 - 48 : 0;
 
 		/* Set up a clipping area for the '/' station preview */
 		if (FillDrawPixelInfo(&tmp_dpi, 7, 26 + y_offset, 66, 48)) {
@@ -1060,8 +1120,8 @@
 		DrawString(this->widget[BRSW_PLATFORM_LEN_1].left, this->widget[BRSW_PLATFORM_LEN_7].right, 141 + y_offset, STR_3066_COVERAGE_AREA_HIGHLIGHT, TC_FROMSTRING, SA_CENTER);
 
 		int text_end = DrawStationCoverageAreaText(2, 166 + y_offset, SCT_ALL, rad, false);
-		text_end = DrawStationCoverageAreaText(2, text_end + 4, SCT_ALL, rad, true) + 4;
-		if (text_end != this->widget[BRSW_BACKGROUND].bottom) {
+		    text_end = DrawStationCoverageAreaText(2, text_end + 2, SCT_ALL, rad, true) + 4;
+		if (text_end != this->widget[BRSW_BACKGROUND].bottom && !imp_newstations) {
 			this->SetDirty();
 			ResizeWindowForWidget(this, BRSW_BACKGROUND, 0, text_end - this->widget[BRSW_BACKGROUND].bottom);
 			this->SetDirty();
@@ -1070,20 +1130,61 @@
 		if (newstations) {
 			uint y = 35;
 
-			for (uint16 i = this->vscroll.pos; i < _railstation.station_count && i < (uint)(this->vscroll.pos + this->vscroll.cap); i++) {
-				const StationSpec *statspec = GetCustomStationSpec(_railstation.station_class, i);
+			if (!imp_newstations) {
+				for (uint16 i = this->vscroll.pos; i < _railstation.station_count && i < (uint)(this->vscroll.pos + this->vscroll.cap); i++) {
+					const StationSpec *statspec = GetCustomStationSpec(_railstation.station_class, i);
 
-				if (statspec != NULL && statspec->name != 0) {
-					if (HasBit(statspec->callbackmask, CBM_STATION_AVAIL) && GB(GetStationCallback(CBID_STATION_AVAILABILITY, 0, 0, statspec, NULL, INVALID_TILE), 0, 8) == 0) {
-						GfxFillRect(8, y - 2, 127, y + 10, 0, FILLRECT_CHECKER);
+					if (statspec != NULL && statspec->name != 0) {
+						if (HasBit(statspec->callbackmask, CBM_STATION_AVAIL) && GB(GetStationCallback(CBID_STATION_AVAILABILITY, 0, 0, statspec, NULL, INVALID_TILE), 0, 8) == 0) {
+							GfxFillRect(8, y - 2, 127, y + 10, 0, FILLRECT_CHECKER);
+						}
+
+					DrawString(9, 127, y, statspec->name, i == _railstation.station_type ? TC_WHITE : TC_BLACK);
+					} else {
+					DrawString(9, 127, y, STR_STAT_CLASS_DFLT, i == _railstation.station_type ? TC_WHITE : TC_BLACK);
 					}
 
-					DrawString(9, 127, y, statspec->name, i == _railstation.station_type ? TC_WHITE : TC_BLACK);
-				} else {
-					DrawString(9, 127, y, STR_STAT_CLASS_DFLT, i == _railstation.station_type ? TC_WHITE : TC_BLACK);
+					y += 14;
+				}
+			} else {
+				y = 22;
+				for (uint16 i = this->vscroll.pos; i < _railstation.station_class_count && i < (uint)(this->vscroll.pos + this->vscroll.cap); i++) {
+					DrawString(9, 127, y, _railstation.station_classes[i]->string,
+							_railstation.station_classes[i]->result == (StationClassID)_railstation.station_class ? TC_WHITE : TC_BLACK);
+					y += 12;
 				}
 
-				y += 14;
+
+				y = 0;
+				int x = 0, width = this->widget[BRSW_NEWGUI_STATIONS_LIST].data & 0xFF;
+				for (uint16 i = this->vscroll2.pos; i < this->vscroll2.count && i < (uint)(this->vscroll2.pos + this->vscroll2.cap); i++) {
+					// TODO: Can the _dpi switching be done once per for loop? or completely outside the loop?
+					//		I had a graphical weirdness once but check to see if this is what caused it
+					x = 0;
+					for (uint16 station = i * width; station < _railstation.station_count && station < (i + 1) * width; station++) {
+						if (_railstation.station_type == station)
+							DrawFrameRect(144 + x, 19 + y, 208 + x, 67 + y, this->widget[BRSW_NEWGUI_STATIONS_LIST].colour, FR_LOWERED);
+
+						if (FillDrawPixelInfo(&tmp_dpi, 144 + x, 21 + y, 64, 46)) {
+							old_dpi = _cur_dpi;
+							_cur_dpi = &tmp_dpi;
+							if (!DrawStationTile(32, 16, _cur_railtype, _railstation.orientation, _railstation.station_class, station)) {
+								StationPickerDrawSprite(32, 16, STATION_RAIL, _cur_railtype, INVALID_ROADTYPE, 2 + _railstation.orientation);
+							}
+							_cur_dpi = old_dpi;
+						}
+
+						const StationSpec *statspec = GetCustomStationSpec(_railstation.station_class, station);
+						if (statspec != NULL &&
+							statspec->name != 0 &&
+							HasBit(statspec->callbackmask, CBM_STATION_AVAIL) &&
+							GB(GetStationCallback(CBID_STATION_AVAILABILITY, 0, 0, statspec, NULL, INVALID_TILE), 0, 8) == 0)
+								GfxFillRect(145 + x, 21 + y, 207 + x, 66 + y, 0, FILLRECT_CHECKER);
+
+						x += 65;
+					}
+					y += 48;
+				}
 			}
 		}
 	}
@@ -1241,6 +1342,81 @@
 				DeleteWindowById(WC_SELECT_STATION, 0);
 				break;
 			}
+
+			// Improved newstation gui - Class selector
+			case BRSW_NEWGUI_LIST: {
+				int y = (pt.y - 20) / 12;
+				if (y >= this->vscroll.cap) return;
+				y += this->vscroll.pos;
+				if (y >= _railstation.station_class_count) return;
+
+				if (_railstation.station_class != _railstation.station_classes[y]->result) {
+					_railstation.station_class = (StationClassID)(_railstation.station_classes[y]->result);
+					_railstation.station_type  = 0;
+					_railstation.station_count = GetNumCustomStations(_railstation.station_class);
+
+					this->CheckSelectedSize(GetCustomStationSpec(_railstation.station_class, _railstation.station_type));
+					
+					int width = this->widget[BRSW_NEWGUI_STATIONS_LIST].data & 0xFF;
+					this->vscroll2.count = _railstation.station_count / width  + (_railstation.station_count % width > 0);
+					this->vscroll2.pos   = 0;
+				}
+
+				SndPlayFx(SND_15_BEEP);
+				this->SetDirty();
+				break;
+			}
+
+			// Improved newstation gui - Station selector
+			case BRSW_NEWGUI_STATIONS_LIST: {
+				const StationSpec *statspec;
+				int y = (pt.y - 20)  / 48;
+				int x = (pt.x - 144) / 65;
+				int width = this->widget[BRSW_NEWGUI_STATIONS_LIST].data & 0xFF;
+
+				if (y >= this->vscroll2.cap) return;
+				if (x >= width) return;
+				y += this->vscroll2.pos;
+				if (y * width + x >= _railstation.station_count) return;
+
+				/* Check station availability callback */
+				statspec = GetCustomStationSpec(_railstation.station_class, y * width + x);
+				if (statspec != NULL &&
+					HasBit(statspec->callbackmask, CBM_STATION_AVAIL) &&
+					GB(GetStationCallback(CBID_STATION_AVAILABILITY, 0, 0, statspec, NULL, INVALID_TILE), 0, 8) == 0) return;
+
+				_railstation.station_type = y * width + x;
+
+				this->CheckSelectedSize(statspec);
+
+				SndPlayFx(SND_15_BEEP);
+				this->SetDirty();
+				//DeleteWindowById(WC_SELECT_STATION, 0);
+				break;
+			}
+		}
+	}
+
+	virtual void OnRightClick(Point pt, int widget)
+	{
+		if (widget >= BRSW_NEWGUI_STATIONS_LIST) {
+			const StationSpec *statspec;
+			int y = (pt.y - 20)  / 48;
+			int x = (pt.x - 144) / 65;
+			int width = this->widget[BRSW_NEWGUI_STATIONS_LIST].data & 0xFF;
+
+			if (y >= this->vscroll2.cap) return;
+			if (x >= width) return;
+			y += this->vscroll2.pos;
+			if (y * width + x >= _railstation.station_count) return;
+
+			// Check station availability callback
+			statspec = GetCustomStationSpec(_railstation.station_class, y * width + x);
+
+			if (statspec != NULL && statspec->name != 0)
+				GuiShowTooltips(statspec->name);
+			else
+				GuiShowTooltips(STR_STAT_CLASS_DFLT);
 		}
 	}
 
@@ -1266,6 +1442,27 @@
 	{
 		CheckRedrawStationCoverage(this);
 	}
+
+	virtual void OnResize(Point delta)
+	{
+		int resize_y = delta.y / (int)this->resize.step_height;
+		//  The station class list resizes 4 listings for every 1 station preview
+		this->vscroll.cap  += resize_y * 4;
+		this->vscroll2.cap += resize_y;
+
+		int width = (this->widget[BRSW_NEWGUI_STATIONS_LIST].data & 0xFF) + delta.x / (int)this->resize.step_width;
+		this->vscroll2.count = _railstation.station_count / width  + (_railstation.station_count % width > 0);
+
+		this->widget[BRSW_NEWGUI_LIST].data          = (this->vscroll.cap  << 8) + 1;
+		this->widget[BRSW_NEWGUI_STATIONS_LIST].data = (this->vscroll2.cap << 8) + width;
+
+		int top = this->vscroll.count - this->vscroll.cap, top2 = this->vscroll2.count - this->vscroll2.cap;
+		this->vscroll.pos  = Clamp(_railstation.station_class       , 0, top  > 0 ? top  : 0);
+		this->vscroll2.pos = Clamp(_railstation.station_type / width, 0, top2 > 0 ? top2 : 0);
+
+		_railstation.window_size.x = this->width;
+		_railstation.window_size.y = this->height;
+	}
 };
 
 /** Widget definition of the standard build rail station window */
@@ -1333,6 +1530,50 @@
 {   WIDGETS_END},
 };
 
+/** Widget definition of the improved build NewGRF rail station window */
+static const Widget _imp_newstation_builder_widgets[] = {
+{   WWT_CLOSEBOX,   RESIZE_NONE,  COLOUR_DARK_GREEN,   0,    10,     0,    13, STR_00C5,                        STR_018B_CLOSE_WINDOW},               // BRSW_CLOSEBOX
+{    WWT_CAPTION,  RESIZE_RIGHT,  COLOUR_DARK_GREEN,  11,   222,     0,    13, STR_3000_RAIL_STATION_SELECTION, STR_018C_WINDOW_TITLE_DRAG_THIS},     // BRSW_CAPTION
+{      WWT_PANEL,     RESIZE_RB,  COLOUR_DARK_GREEN,   0,   222,    14,   260, 0x0,                             STR_NULL},                            // BRSW_BACKGROUND
+{      WWT_PANEL,     RESIZE_TB,  COLOUR_GREY,         7,    72,    68,   115, 0x0,                             STR_304E_SELECT_RAILROAD_STATION},    // BRSW_PLATFORM_DIR_X
+{      WWT_PANEL,     RESIZE_TB,  COLOUR_GREY,        75,   140,    68,   115, 0x0,                             STR_304E_SELECT_RAILROAD_STATION},    // BRSW_PLATFORM_DIR_Y
+
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        22,    36,   129,   140, STR_00CB_1,                      STR_304F_SELECT_NUMBER_OF_PLATFORMS}, // BRSW_PLATFORM_NUM_1
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        37,    51,   129,   140, STR_00CC_2,                      STR_304F_SELECT_NUMBER_OF_PLATFORMS}, // BRSW_PLATFORM_NUM_2
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        52,    66,   129,   140, STR_00CD_3,                      STR_304F_SELECT_NUMBER_OF_PLATFORMS}, // BRSW_PLATFORM_NUM_3
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        67,    81,   129,   140, STR_00CE_4,                      STR_304F_SELECT_NUMBER_OF_PLATFORMS}, // BRSW_PLATFORM_NUM_4
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        82,    96,   129,   140, STR_00CF_5,                      STR_304F_SELECT_NUMBER_OF_PLATFORMS}, // BRSW_PLATFORM_NUM_5
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        97,   111,   129,   140, STR_6,                           STR_304F_SELECT_NUMBER_OF_PLATFORMS}, // BRSW_PLATFORM_NUM_6
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,       112,   126,   129,   140, STR_7,                           STR_304F_SELECT_NUMBER_OF_PLATFORMS}, // BRSW_PLATFORM_NUM_7
+
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        22,    36,   154,   165, STR_00CB_1,                      STR_3050_SELECT_LENGTH_OF_RAILROAD},  // BRSW_PLATFORM_LEN_1
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        37,    51,   154,   165, STR_00CC_2,                      STR_3050_SELECT_LENGTH_OF_RAILROAD},  // BRSW_PLATFORM_LEN_2
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        52,    66,   154,   165, STR_00CD_3,                      STR_3050_SELECT_LENGTH_OF_RAILROAD},  // BRSW_PLATFORM_LEN_3
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        67,    81,   154,   165, STR_00CE_4,                      STR_3050_SELECT_LENGTH_OF_RAILROAD},  // BRSW_PLATFORM_LEN_4
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        82,    96,   154,   165, STR_00CF_5,                      STR_3050_SELECT_LENGTH_OF_RAILROAD},  // BRSW_PLATFORM_LEN_5
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        97,   111,   154,   165, STR_6,                           STR_3050_SELECT_LENGTH_OF_RAILROAD},  // BRSW_PLATFORM_LEN_6
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,       112,   126,   154,   165, STR_7,                           STR_3050_SELECT_LENGTH_OF_RAILROAD},  // BRSW_PLATFORM_LEN_7
+
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        37,   111,   168,   179, STR_DRAG_DROP,                   STR_STATION_DRAG_DROP},               // BRSW_PLATFORM_DRAG_N_DROP
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        14,    73,   194,   205, STR_02DB_OFF,                    STR_3065_DON_T_HIGHLIGHT_COVERAGE},   // BRSW_HIGHLIGHT_OFF
+{    WWT_TEXTBTN,     RESIZE_TB,  COLOUR_GREY,        74,   133,   194,   205, STR_02DA_ON,                     STR_3064_HIGHLIGHT_COVERAGE_AREA},    // BRSW_HIGHLIGHT_ON
+
+// Spacers to keep compatability with enum that includes old newstation gui
+{      WWT_EMPTY,   RESIZE_NONE,  COLOUR_GREY,         0,     0,     0,     0, 0x0,                             STR_NULL},
+{      WWT_EMPTY,   RESIZE_NONE,  COLOUR_GREY,         0,     0,     0,     0, 0x0,                             STR_NULL},
+{      WWT_EMPTY,   RESIZE_NONE,  COLOUR_GREY,         0,     0,     0,     0, 0x0,                             STR_NULL},
+
+// improved newstations gui additions
+{     WWT_MATRIX, RESIZE_BOTTOM,  COLOUR_GREY,         7,   128,    20,   56, 0x301,                           STR_SELECT_STATION_CLASS_TIP},        // BRSW_NEWGUI_LIST
+{  WWT_SCROLLBAR, RESIZE_BOTTOM,  COLOUR_GREY,       129,   140,    20,   56, 0x0,                             STR_0190_SCROLL_BAR_SCROLLS_LIST},    // BRSW_NEWGUI_SCROLL
+
+{     WWT_MATRIX,     RESIZE_RB,  COLOUR_GREY,       144,   208,    20,   259, 0x501,                           STR_NULL},                            // BRSW_NEWGUI_STATIONS_LIST
+
+{ WWT_SCROLL2BAR,    RESIZE_LRB,  COLOUR_GREY,       209,   220,    20,   248, 0x0,                             STR_0190_SCROLL_BAR_SCROLLS_LIST},    // BRSW_NEWGUI_SCROLL
+{  WWT_RESIZEBOX,   RESIZE_LRTB,  COLOUR_GREY,       209,   220,   248,   259, 0x0,                             STR_RESIZE_BUTTON},
+{   WIDGETS_END},
+};
+
 /** High level window description of the default station-build window */
 static const WindowDesc _station_builder_desc(
 	WDP_AUTO, WDP_AUTO, 148, 200, 148, 200,
@@ -1349,13 +1590,24 @@
 	_newstation_builder_widgets
 );
 
+/** High level window description of the newGRF station-build window */
+static const WindowDesc _imp_newstation_builder_desc(
+	WDP_AUTO, WDP_AUTO, 223, 261, 288, 309,
+	WC_BUILD_STATION, WC_BUILD_TOOLBAR,
+	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_CONSTRUCTION | WDF_RESIZABLE,
+	_imp_newstation_builder_widgets
+);
+
 /** Open station build window */
 static void ShowStationBuilder(Window *parent)
 {
 	if (GetNumStationClasses() <= 2 && GetNumCustomStations(STAT_CLASS_DFLT) == 1) {
 		new BuildRailStationWindow(&_station_builder_desc, parent, false);
 	} else {
-		new BuildRailStationWindow(&_newstation_builder_desc, parent, true);
+		if(_settings_client.gui.imp_newstations_gui)
+			new BuildRailStationWindow(&_imp_newstation_builder_desc, parent, true);
+		else
+			new BuildRailStationWindow(&_newstation_builder_desc, parent, true);
 	}
 }
 
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/screenshot.cpp
--- src/screenshot.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/screenshot.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -16,6 +16,9 @@
 #include "map_func.h"
 #include "saveload/saveload.h"
 #include "company_func.h"
+#include "settings_type.h"
+#include "signs_base.h"
+#include "landscape.h"
 
 
 char _screenshot_format_name[8];
@@ -548,6 +551,42 @@
 	return filename;
 }
 
+static char *MakeTimelapseScreenshotName(const char *ext, const char *name = NULL)
+{
+	/* Path for automatic screenshots */
+	static char autoscreen_dir[MAX_PATH];
+	snprintf(autoscreen_dir, lengthof(autoscreen_dir), "%s%s%s", _personal_dir, "auto_screenshot", PATHSEP);
+	if (!FileExists(autoscreen_dir)) FioCreateDirectory(autoscreen_dir);
+	if (name != NULL) {
+		/* For local screens use subdirectory */
+		snprintf(autoscreen_dir, lengthof(autoscreen_dir), "%s%s%s", autoscreen_dir, name, PATHSEP);
+		if (!FileExists(autoscreen_dir)) FioCreateDirectory(autoscreen_dir);
+	}
+
+	/* File name base - "timelapse" */
+	ttd_strlcpy(_screenshot_name, "timelapse", lengthof(_screenshot_name));
+	size_t len = strlen(_screenshot_name);
+	/* Add '#' */
+	snprintf(&_screenshot_name[len], lengthof(_screenshot_name) - len, "#");
+	SanitizeFilename(_screenshot_name);
+	len = strlen(_screenshot_name);
+	/* Add initial numbers and file extension */
+	snprintf(&_screenshot_name[len], lengthof(_screenshot_name) - len, "000000.%s", ext);
+
+	uint diff = 5; // number of preceding zeros
+	static char filename[MAX_PATH];
+	for (uint serial = 1;; serial++) {
+		/* Try if the file name is available */
+		snprintf(filename, lengthof(filename), "%s%s", autoscreen_dir, _screenshot_name);
+		if (!FileExists(filename)) break;
+		/* If file already exists increase the serial */
+		if (serial == 10 || serial == 100 || serial == 1000 || serial == 10000 || serial == 100000) diff--;
+		snprintf(&_screenshot_name[len + diff], lengthof(_screenshot_name) - len, "%d.%s", serial, ext);
+	}
+
+	return filename;
+}
+
 void SetScreenshotType(ScreenshotType t)
 {
 	current_screenshot_type = t;
@@ -583,7 +622,52 @@
 	return sf->proc(MakeScreenshotName(sf->extension), LargeWorldCallback, &vp, vp.width, vp.height, BlitterFactoryBase::GetCurrentBlitter()->GetScreenDepth(), _cur_palette);
 }
 
-bool MakeScreenshot()
+static bool MakeTimelapseScreenshot()
+{
+	ViewPort vp;
+	const ScreenshotFormat *sf;
+
+	uint8 zoom = _settings_client.gui.auto_screenshot_zoomlvl;
+
+	vp.zoom = (ZoomLevel)zoom;
+	vp.left = 0;
+	vp.top = 0;
+	vp.virtual_left = -(int)MapMaxX() * TILE_PIXELS;
+	vp.virtual_top = 0;
+	vp.virtual_width = (MapMaxX() + MapMaxY()) * TILE_PIXELS >> zoom;
+	vp.width = vp.virtual_width;
+	vp.virtual_height = (MapMaxX() + MapMaxY()) * (TILE_PIXELS >> 1) >> zoom;
+	vp.height = vp.virtual_height;
+
+	sf = _screenshot_formats + _cur_screenshot_format;
+	return sf->proc(MakeTimelapseScreenshotName(sf->extension), LargeWorldCallback, &vp, vp.width, vp.height, BlitterFactoryBase::GetCurrentBlitter()->GetScreenDepth(), _cur_palette);
+}
+
+static bool MakeTimelapseLocalScreenshot(const char *name, const Point *pt)
+{
+	ViewPort vp;
+	const ScreenshotFormat *sf;
+
+	uint16 size_x = _settings_client.gui.auto_local_screen_size_x;
+	uint16 size_y = _settings_client.gui.auto_local_screen_size_y;
+	uint8 zoom = _settings_client.gui.auto_local_screen_zoomlvl;
+
+	vp.zoom = ZoomLevel(zoom);
+
+	vp.left = 0;
+	vp.top = 0;
+	vp.virtual_left = pt->x - ((size_x / 2) << zoom);
+	vp.virtual_top = pt->y - ((size_y / 2) << zoom);
+	vp.virtual_width = size_x;
+	vp.width = vp.virtual_width;
+	vp.virtual_height = size_y;
+	vp.height = vp.virtual_height;
+
+	sf = _screenshot_formats + _cur_screenshot_format;
+	return sf->proc(MakeTimelapseScreenshotName(sf->extension, name), LargeWorldCallback, &vp, vp.width, vp.height, BlitterFactoryBase::GetCurrentBlitter()->GetScreenDepth(), _cur_palette);
+}
+
+bool MakeScreenshot(const void *name, const void *pt)
 {
 	switch (current_screenshot_type) {
 		case SC_VIEWPORT:
@@ -594,6 +678,12 @@
 		case SC_WORLD:
 			current_screenshot_type = SC_NONE;
 			return MakeWorldScreenshot();
+		case SC_TIMELAPSE:
+			current_screenshot_type = SC_NONE;
+			return MakeTimelapseScreenshot();
+		case SC_TIMELAPSE_LOCAL:
+			current_screenshot_type = SC_NONE;
+			return MakeTimelapseLocalScreenshot((const char*) name, (const Point*) pt);
 		default: return false;
 	}
 }
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/screenshot.h
--- src/screenshot.h	Sun Apr 12 15:17:27 2009 +0000
+++ src/screenshot.h	Sun Apr 12 18:10:09 2009 +0200
@@ -13,10 +13,12 @@
 enum ScreenshotType {
 	SC_NONE,
 	SC_VIEWPORT,
-	SC_WORLD
+	SC_WORLD,
+	SC_TIMELAPSE,
+	SC_TIMELAPSE_LOCAL
 };
 
-bool MakeScreenshot();
+bool MakeScreenshot(const void *name = NULL, const void *pt = NULL);
 void SetScreenshotType(ScreenshotType t);
 bool IsScreenshotRequested();
 
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/settings_gui.cpp
--- src/settings_gui.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/settings_gui.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -1098,6 +1098,7 @@
 	SettingEntry("gui.status_long_date"),
 	SettingEntry("gui.date_format_in_default_names"),
 	SettingEntry("gui.population_in_label"),
+	SettingEntry("gui.rating_in_label"),
 	SettingEntry("gui.measure_tooltip"),
 	SettingEntry("gui.loading_indicators"),
 	SettingEntry("gui.liveries"),
@@ -1129,9 +1130,24 @@
 /** Interaction sub-page */
 static SettingsPage _settings_ui_interaction_page = {_settings_ui_interaction, lengthof(_settings_ui_interaction)};
 
+static SettingEntry _settings_ui_automatic_screenshots[] = {
+	SettingEntry("gui.auto_screenshot"),
+	SettingEntry("gui.auto_screenshot_interval"),
+	SettingEntry("gui.auto_screenshot_num_commands"),
+	SettingEntry("gui.auto_screenshot_zoomlvl"),
+	SettingEntry("gui.auto_local_screen"),
+	SettingEntry("gui.auto_local_screen_types"),
+	SettingEntry("gui.auto_local_screen_interval"),
+	SettingEntry("gui.auto_local_screen_num_commands"),
+	SettingEntry("gui.auto_local_screen_zoomlvl"),
+};
+/** Automatic Screenshots sub-page */
+static SettingsPage _settings_ui_automatic_screenshots_page = {_settings_ui_automatic_screenshots, lengthof(_settings_ui_automatic_screenshots)};
+
 static SettingEntry _settings_ui[] = {
 	SettingEntry(&_settings_ui_display_page, STR_CONFIG_SETTING_DISPLAY_OPTIONS),
 	SettingEntry(&_settings_ui_interaction_page, STR_CONFIG_SETTING_INTERACTION),
+	SettingEntry(&_settings_ui_automatic_screenshots_page, STR_CONFIG_SETTING_AUTOMATIC_SCREENSHOTS),
 	SettingEntry("gui.show_finances"),
 	SettingEntry("gui.errmsg_duration"),
 	SettingEntry("gui.toolbar_pos"),
@@ -1143,6 +1159,7 @@
 	SettingEntry("gui.always_build_infrastructure"),
 	SettingEntry("gui.persistent_buildingtools"),
 	SettingEntry("gui.coloured_news_year"),
+	SettingEntry("gui.imp_newstations_gui"),
 };
 /** Interface subpage */
 static SettingsPage _settings_ui_page = {_settings_ui, lengthof(_settings_ui)};
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/settings_type.h
--- src/settings_type.h	Sun Apr 12 15:17:27 2009 +0000
+++ src/settings_type.h	Sun Apr 12 18:10:09 2009 +0200
@@ -65,6 +65,7 @@
 	uint8  date_format_in_default_names;     ///< should the default savegame/screenshot name use long dates (31th Dec 2008), short dates (31-12-2008) or ISO dates (2008-12-31)
 	byte   max_num_autosaves;                ///< controls how many autosavegames are made before the game starts to overwrite (names them 0 to max_num_autosaves - 1)
 	bool   population_in_label;              ///< show the population of a town in his label?
+	bool   rating_in_label;                  ///< show the rating of a town in its label
 	uint8  right_mouse_btn_emulation;        ///< should we emulate right mouse clicking?
 	uint8  scrollwheel_scrolling;            ///< scrolling using the scroll wheel?
 	uint8  scrollwheel_multiplier;           ///< how much 'wheel' per incoming event from the OS?
@@ -91,6 +92,20 @@
 	bool   station_show_coverage;            ///< whether to highlight coverage area
 	bool   persistent_buildingtools;         ///< keep the building tools active after usage
 	uint8  expenses_layout;                  ///< layout of expenses window
+	bool   imp_newstations_gui;              ///< use the new newstations selection ui
+
+	uint8  auto_screenshot;                  ///< automatically take giant screenshots (0 = off, 1 = after time interval, 2 = after number of commands, 3 = after time interval, but only if a number of commands were issued inbetween)
+	uint16 auto_screenshot_interval;         ///< the time interval for automatic giant screenshots
+	uint16 auto_screenshot_num_commands;     ///< the number of commands for automatic giant screenshots
+	uint8  auto_screenshot_zoomlvl;          ///< the zoom level used for automatic giant screenshots (zoomed out means smaller filesize but less quality)
+	uint8  auto_local_screen;                ///< automatically take local screenshots (0 = off, 1 = after time interval, 2 = after number of commands, 3 = after time interval, but only if a number of commands were issued inbetween)
+	uint8  auto_local_screen_types;          ///< where to take local screenshots (0 = at signs, 1 = at stations, 2 = at signs and stations)
+	uint16 auto_local_screen_interval;       ///< the interval for automatic local screenshots
+	uint16 auto_local_screen_num_commands;   ///< the number of commands for automatic local screenshots
+	uint16 auto_local_screen_zoomlvl;        ///< the zoom level used for automatic local screenshots
+	uint16 auto_local_screen_size_x;         ///< width of automatic local screenshots
+	uint16 auto_local_screen_size_y;         ///< heigth of automatic local screenshots
+	uint8  auto_local_screen_prefix;         ///< the character used to specify local screen signs (# by default)
 
 	uint16 console_backlog_timeout;          ///< the minimum amount of time items should be in the console backlog before they will be removed in ~3 seconds granularity.
 	uint16 console_backlog_length;           ///< the minimum amount of items in the console backlog before items will be removed.
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/signs_gui.cpp
--- src/signs_gui.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/signs_gui.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -20,12 +20,25 @@
 
 #include "table/strings.h"
 
+struct FilterInfo {
+	const char *string;
+	bool case_sensitive;
+};
+
 struct SignList {
-	typedef GUIList<const Sign *> GUISignList;
+	typedef GUIList<const Sign *, FilterInfo> GUISignList;
 
 	static const Sign *last_sign;
 	GUISignList signs;
 
+	char filter_string[MAX_LENGTH_SIGN_NAME_BYTES];
+	bool match_case;
+
+	SignList(){
+		memset(filter_string, '\0', sizeof(this->filter_string));
+		this->match_case = false;
+	}
+
 	void BuildSignsList()
 	{
 		if (!this->signs.NeedRebuild()) return;
@@ -37,6 +50,7 @@
 		const Sign *si;
 		FOR_ALL_SIGNS(si) *this->signs.Append() = si;
 
+		this->FilterSignList();
 		this->signs.Compact();
 		this->signs.RebuildDone();
 	}
@@ -66,6 +80,23 @@
 		/* Reset the name sorter sort cache */
 		this->last_sign = NULL;
 	}
+
+	/** Filter sign list by sign name (case sensitive setting in FilterInfo) */
+	static bool CDECL SignNameFilter(const Sign * const *a, FilterInfo filter_info)
+	{
+		/* Get sign string */
+		char buf1[64];
+		SetDParam(0, (*a)->index);
+		GetString(buf1, STR_SIGN_NAME, lastof(buf1));
+
+		return (filter_info.case_sensitive ? strstr(buf1, filter_info.string) : strcasestr(buf1, filter_info.string)) != NULL;
+	}
+
+	void FilterSignList()
+	{
+		FilterInfo filter_info = {this->filter_string, this->match_case};
+		this->signs.Filter(&SignNameFilter, filter_info);
+	}
 };
 
 const Sign *SignList::last_sign = NULL;
@@ -77,22 +108,118 @@
 	SLW_STICKY,
 	SLW_LIST,
 	SLW_SCROLLBAR,
+	SLW_FILTER_TEXT,
+	SLW_FILTER_MATCH_CASE_BTN,
+	SLW_FILTER_CLEAR_BTN,
 	SLW_RESIZE,
 };
 
-struct SignListWindow : Window, SignList {
-	SignListWindow(const WindowDesc *desc, WindowNumber window_number) : Window(desc, window_number)
+struct SignListWindow : QueryStringBaseWindow, SignList {
+private:
+	int selected_sign;
+
+public:
+	SignListWindow(const WindowDesc *desc, WindowNumber window_number) : QueryStringBaseWindow(MAX_LENGTH_SIGN_NAME_BYTES, desc)
 	{
-		this->vscroll.cap = 12;
+		this->vscroll.cap = 11;
 		this->resize.step_height = 10;
 		this->resize.height = this->height - 10 * 7; // minimum if 5 in the list
 
+		this->InitializeFilterTextWidget();
+		this->SetFilterString("");
+		this->selected_sign = -1;
+ 
 		this->signs.ForceRebuild();
 		this->signs.NeedResort();
 
 		this->FindWindowPlacementAndResize(desc);
 	}
 
+	void InitializeFilterTextWidget()
+	{
+		this->afilter = CS_ALPHANUMERAL;
+		this->LowerWidget(SLW_FILTER_TEXT);
+
+		/* Display an empty string in the edit box */
+		GetString(this->edit_str_buf, STR_EMPTY, lastof(this->edit_str_buf));
+
+		this->edit_str_buf[lengthof(this->edit_str_buf) - 1] = '\0';
+
+		InitializeTextBuffer(&this->text, this->edit_str_buf, MAX_LENGTH_SIGN_NAME_BYTES, 255); // Allow MAX_LENGTH_SIGN_NAME_BYTES characters (including \0)
+
+		this->InvalidateWidget(SLW_FILTER_TEXT);
+	}
+
+	void SetFilterString(const char* new_filter_string)
+	{
+		/* clear this->filter_string */
+		memset(this->filter_string, '\0', sizeof(this->filter_string));
+
+		/* check if there is a new filter string */ 
+		if (new_filter_string != 0 && strlen(new_filter_string) != 0) {
+			/* Copy new filter string */
+			strncpy(this->filter_string, new_filter_string, strlen(new_filter_string));
+			this->filter_string[strlen(new_filter_string)] = '\0';
+
+			this->signs.SetFilterState(true);
+		}
+		else
+			this->signs.SetFilterState(false);
+
+		this->UpdateList();
+	}
+
+	void UpdateList()
+	{
+		/* Rebuild list of signs that are displayed. */
+		this->signs.ForceRebuild();
+
+		/* Re-paint widgets that need to be repainted */
+		this->InvalidateWidget(SLW_LIST);
+		this->InvalidateWidget(SLW_SCROLLBAR);
+		this->InvalidateWidget(SLW_CAPTION);
+	}
+
+	void SelectNextSign()
+	{
+		this->selected_sign++;
+		if (this->selected_sign != -1 && (unsigned int) this->selected_sign >= this->signs.Length()) {
+			this->selected_sign = this->signs.Length () - 1;
+		}
+
+		/* Scroll down a half page if moving below last line  */
+		if (this->selected_sign >= this->vscroll.cap + this->vscroll.pos)
+		{
+			int pos = Clamp(this->vscroll.pos + this->vscroll.cap/2 + 1,  0, this->vscroll.count - this->vscroll.cap);
+			this->vscroll.pos = pos;
+			//this->SetDirty();
+			this->InvalidateWidget(SLW_SCROLLBAR);
+		}
+
+		this->InvalidateWidget(SLW_LIST);
+	}
+
+	void SelectPreviousSign()
+	{
+		this->selected_sign--;
+		if (this->selected_sign < 0) {
+			this->selected_sign = 0;
+		} else if ((unsigned int) this->selected_sign >= this->signs.Length()) {
+			this->selected_sign = this->signs.Length () - 1;
+		}
+
+		/* Scroll up a half page if moving above first line  */
+		if (this->selected_sign < this->vscroll.pos)
+		{
+			int pos = Clamp(this->vscroll.pos - this->vscroll.cap/2 - 1,  0, this->vscroll.count - this->vscroll.cap);
+			this->vscroll.pos = pos;
+			//this->SetDirty();
+			this->InvalidateWidget(SLW_SCROLLBAR);
+		}
+		
+		this->InvalidateWidget(SLW_LIST);
+ 	}
+
 	virtual void OnPaint()
 	{
 		BuildSignsList();
@@ -102,6 +229,7 @@
 
 		SetDParam(0, this->vscroll.count);
 		this->DrawWidgets();
+		this->DrawEditBox(SLW_FILTER_TEXT);
 
 		/* No signs? */
 		int y = this->widget[SLW_LIST].top + 2; // offset from top of widget
@@ -118,24 +246,119 @@
 
 			SetDParam(0, si->index);
 			DrawString(this->widget[SLW_LIST].left + 22, this->widget[SLW_LIST].right, y, STR_SIGN_NAME, TC_YELLOW);
+			if (this->selected_sign == i)
+				DrawString(this->widget[SLW_LIST].left + 22, this->widget[SLW_LIST].right, y, STR_SIGN_NAME, TC_BLUE);
+			else
+				DrawString(this->widget[SLW_LIST].left + 22, this->widget[SLW_LIST].right, y, STR_SIGN_NAME, TC_YELLOW);
 			y += 10;
 		}
 	}
 
 	virtual void OnClick(Point pt, int widget)
 	{
-		if (widget == SLW_LIST) {
-			uint32 id_v = (pt.y - this->widget[SLW_LIST].top - 1) / 10;
+		switch (widget) {
+			case SLW_LIST:
+			{ // <- needed or the compiler will complain
+				uint32 id_v = (pt.y - this->widget[SLW_LIST].top - 1) / 10;
 
-			if (id_v >= this->vscroll.cap) return;
-			id_v += this->vscroll.pos;
-			if (id_v >= this->vscroll.count) return;
+				if (id_v >= this->vscroll.cap) return;
+				id_v += this->vscroll.pos;
+				if (id_v >= this->vscroll.count) return;
 
-			const Sign *si = this->signs[id_v];
-			ScrollMainWindowToTile(TileVirtXY(si->x, si->y));
+				const Sign *si = this->signs[id_v];
+				ScrollMainWindowToTile(TileVirtXY(si->x, si->y));
+				break;
+			}
+
+			case SLW_FILTER_CLEAR_BTN:
+				this->InitializeFilterTextWidget();
+				this->SetFilterString(0);
+				this->selected_sign = -1;
+				break;
+
+			case SLW_FILTER_MATCH_CASE_BTN:
+				this->match_case = !this->match_case;
+				if (this->match_case) {
+					this->LowerWidget(SLW_FILTER_MATCH_CASE_BTN);
+				} else {
+					this->RaiseWidget(SLW_FILTER_MATCH_CASE_BTN);
+				}
+				this->UpdateList();
+				break;
 		}
 	}
 
+	virtual EventState OnKeyPress(uint16 key, uint16 keycode)
+	{
+		EventState state = ES_NOT_HANDLED;
+		switch (this->HandleEditBoxKey(SLW_FILTER_TEXT, key, keycode, state)) {
+			case HEBR_EDITING:
+				break;
+
+			case HEBR_CONFIRM: // Enter pressed -> goto first sign in list
+			{
+				uint n_signs = this->signs.Length();
+				if (n_signs >= 1) {
+					/* highlight first sign if selected_sign is == -1 or if a sign below the end of list is selected */
+					uint sign_id = this->selected_sign == -1 || (uint)this->selected_sign >= n_signs? 0 : this->selected_sign;
+					if (n_signs > sign_id) {
+						const Sign* si = this->signs[sign_id];
+						ScrollMainWindowToTile(TileVirtXY(si->x, si->y));
+					}
+				}
+				return state;
+			}
+
+			case HEBR_CANCEL: // ESC pressed, clear filter
+				this->InitializeFilterTextWidget(); // Empty the text in the EditBox widget
+				this->SetFilterString(0);           // Use empty text as filter text (= view all signs)
+				this->focused_widget = 0;           // Unfocus the text box
+				this->selected_sign = -1;           // Deselect sign in sign list
+				return state;
+
+			case HEBR_NOT_FOCUSED: // The filter text box is not globaly focused
+				if (keycode == 'F') { // Hotkey to enable filter box
+					this->SetFocusedWidget(SLW_FILTER_TEXT);
+					SetFocusedWindow(this); // The user has asked to give focus to the text box, so make sure this window is focused.
+					state = ES_HANDLED;
+				}
+				break;
+
+			default:
+				NOT_REACHED();
+		}
+
+		if (state == ES_HANDLED) OnOSKInput(SLW_FILTER_TEXT);
+
+		// Selection of signs using arrow up/down keys
+		if (this->focused_widget == this->widget + SLW_FILTER_TEXT)
+		{
+			switch (keycode) {
+				case WKC_UP:
+					this->SelectPreviousSign();
+					state = ES_HANDLED;
+					break;
+
+				case WKC_DOWN:
+					this->SelectNextSign();
+					state = ES_HANDLED;
+			}
+		}
+
+		return state;
+	}
+
+	virtual void OnOSKInput(int wid)
+	{
+		this->SetFilterString(this->text.buf);
+		this->UpdateList();
+	}
+
+	virtual void OnMouseLoop()
+	{
+		this->HandleEditBox(SLW_FILTER_TEXT);
+ 	}
+
 	virtual void OnResize(Point delta)
 	{
 		this->vscroll.cap += delta.y / 10;
@@ -143,7 +366,10 @@
 
 	virtual void OnInvalidateData(int data)
 	{
-		if (data == 0) {
+		/* data == 0: new or deleted sign
+		 * data == 1: sign is renamed
+		 */
+		if (data == 0 || strlen(this->filter_string) != 0) {
 			this->signs.ForceRebuild();
 		} else {
 			this->signs.ForceResort();
@@ -153,10 +379,13 @@
 
 static const Widget _sign_list_widget[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,  COLOUR_GREY,     0,    10,     0,    13, STR_00C5,              STR_018B_CLOSE_WINDOW},
-{    WWT_CAPTION,  RESIZE_RIGHT,  COLOUR_GREY,    11,   345,     0,    13, STR_SIGN_LIST_CAPTION, STR_018C_WINDOW_TITLE_DRAG_THIS},
+{    WWT_CAPTION,  RESIZE_RIGHT,  COLOUR_GREY,    11,   345,     0,    13, STR_SIGN_LIST_CAPTION, STR_018C_WINDOW_TITLE_DRAG_THIS},   // SLW_CAPTION
 {  WWT_STICKYBOX,     RESIZE_LR,  COLOUR_GREY,   346,   357,     0,    13, 0x0,                   STR_STICKY_BUTTON},
-{      WWT_PANEL,     RESIZE_RB,  COLOUR_GREY,     0,   345,    14,   137, 0x0,                   STR_NULL},
-{  WWT_SCROLLBAR,    RESIZE_LRB,  COLOUR_GREY,   346,   357,    14,   125, 0x0,                   STR_0190_SCROLL_BAR_SCROLLS_LIST},
+{      WWT_PANEL,     RESIZE_RB,  COLOUR_GREY,     0,   345,    14,   125, 0x0,                   STR_NULL},                          // SLW_LIST
+{  WWT_SCROLLBAR,    RESIZE_LRB,  COLOUR_GREY,   346,   357,    14,   125, 0x0,                   STR_0190_SCROLL_BAR_SCROLLS_LIST},  // SLW_SCROLLBAR
+{    WWT_EDITBOX,    RESIZE_RTB,  COLOUR_GREY,     0,   165,   126,   137, STR_FILTER_OSKTITLE,   STR_NULL},                          // SLW_FILTER_TEXT
+{ WWT_PUSHTXTBTN,    RESIZE_LRTB, COLOUR_GREY,     166, 255,   126,   137, STR_FILTER_MATCH_CASE, STR_NULL},                          // SLW_FILTER_MATCH_CASE_BTN
+{    WWT_TEXTBTN,    RESIZE_LRTB, COLOUR_GREY,     256, 345,   126,   137, STR_FILTER_CLEAR,      STR_NULL},                          // SLW_FILTER_CLEAR_BTN
 {  WWT_RESIZEBOX,   RESIZE_LRTB,  COLOUR_GREY,   346,   357,   126,   137, 0x0,                   STR_RESIZE_BUTTON},
 {   WIDGETS_END},
 };
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/spritecache.cpp
--- src/spritecache.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/spritecache.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -16,8 +16,8 @@
 
 #include "table/sprites.h"
 
-/* Default of 4MB spritecache */
-uint _sprite_cache_size = 4;
+/* Default of 64MB spritecache */
+uint _sprite_cache_size = 64;
 
 typedef SimpleTinyEnumT<SpriteType, byte> SpriteTypeByte;
 
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/table/settings.h
--- src/table/settings.h	Sun Apr 12 15:17:27 2009 +0000
+++ src/table/settings.h	Sun Apr 12 18:10:09 2009 +0200
@@ -528,6 +528,7 @@
 	  SDTC_VAR(gui.window_snap_radius,        SLE_UINT8, S, D0,    10,        1,       32, 0, STR_CONFIG_SETTING_SNAP_RADIUS,                 NULL),
 	  SDTC_VAR(gui.window_soft_limit,         SLE_UINT8, S, D0,    20,        5,      255, 1, STR_CONFIG_SETTING_SOFT_LIMIT,                  NULL),
 	 SDTC_BOOL(gui.population_in_label,                  S,  0,  true,                        STR_CONFIG_SETTING_POPULATION_IN_LABEL,         PopulationInLabelActive),
+	 SDTC_BOOL(gui.rating_in_label,                      S,  0,  true,                        STR_CONFIG_SETTING_RATING_IN_LABEL,             PopulationInLabelActive),
 	 SDTC_BOOL(gui.link_terraform_toolbar,               S,  0, false,                        STR_CONFIG_SETTING_LINK_TERRAFORM_TOOLBAR,      NULL),
 	  SDTC_VAR(gui.liveries,                  SLE_UINT8, S, MS,     2,        0,        2, 0, STR_CONFIG_SETTING_LIVERIES,                    RedrawScreen),
 	 SDTC_BOOL(gui.prefer_teamchat,                      S,  0, false,                        STR_CONFIG_SETTING_PREFER_TEAMCHAT,             NULL),
@@ -566,6 +567,20 @@
 	 SDTC_BOOL(gui.station_show_coverage,                S,  0, false,                        STR_NULL,                                       NULL),
 	 SDTC_BOOL(gui.persistent_buildingtools,             S,  0, false,                        STR_CONFIG_SETTING_PERSISTENT_BUILDINGTOOLS,    NULL),
 	 SDTC_BOOL(gui.expenses_layout,                      S,  0, false,                        STR_CONFIG_SETTING_EXPENSES_LAYOUT,             RedrawScreen),
+	 SDTC_BOOL(gui.imp_newstations_gui,                  S,  0, false,                        STR_CONFIG_SETTING_IMP_NEWSTATIONS_GUI,         RedrawScreen),
+
+	  SDTC_VAR(gui.auto_screenshot,           SLE_UINT8, S, MS,     0,        0,        3, 1, STR_CONFIG_SETTING_AUTO_GIANT_SCREEN,           NULL),
+	  SDTC_VAR(gui.auto_screenshot_interval, SLE_UINT16, S,  0,    15,        1,     1000, 1, STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_INTERVAL,  NULL),
+	  SDTC_VAR(gui.auto_screenshot_num_commands,SLE_UINT16,S,0,   100,       10,    50000, 1, STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_NUM_COMMANDS, NULL),
+	  SDTC_VAR(gui.auto_screenshot_zoomlvl,   SLE_UINT8, S, MS,     0,        0,        3, 1, STR_CONFIG_SETTING_AUTO_GIANT_SCREEN_ZOOMLVL,   NULL),
+	  SDTC_VAR(gui.auto_local_screen,         SLE_UINT8, S, MS,     0,        0,        3, 1, STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN,           NULL),
+	  SDTC_VAR(gui.auto_local_screen_types,   SLE_UINT8, S, MS,     0,        0,        2, 1, STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_TYPES,     NULL),
+	  SDTC_VAR(gui.auto_local_screen_interval,SLE_UINT16,S,  0,    15,        1,     1000, 1, STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_INTERVAL,  NULL),
+	  SDTC_VAR(gui.auto_local_screen_num_commands,SLE_UINT16,S,0, 100,       10,    50000, 1, STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_NUM_COMMANDS, NULL),
+	  SDTC_VAR(gui.auto_local_screen_zoomlvl, SLE_UINT8, S, MS,     0,        0,        3, 1, STR_CONFIG_SETTING_AUTO_LOCAL_SCREEN_ZOOMLVL,   NULL),
+	  SDTC_VAR(gui.auto_local_screen_size_x, SLE_UINT16, S,  0,   800,      100,     8000, 1, STR_NULL,                                       NULL),
+	  SDTC_VAR(gui.auto_local_screen_size_y, SLE_UINT16, S,  0,   600,      100,     6000, 1, STR_NULL,                                       NULL),
+	  SDTC_VAR(gui.auto_local_screen_prefix,  SLE_UINT8, S,  0,    35,        0,      255, 1, STR_NULL,                                       NULL),
 
 	  SDTC_VAR(gui.console_backlog_timeout,  SLE_UINT16, S,  0,   100,       10,    65500, 0, STR_NULL,                                       NULL),
 	  SDTC_VAR(gui.console_backlog_length,   SLE_UINT16, S,  0,   100,       10,    65500, 0, STR_NULL,                                       NULL),
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/terraform_cmd.cpp
--- src/terraform_cmd.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/terraform_cmd.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -346,12 +346,35 @@
 	return total_cost;
 }
 
+bool LevelSingleTile(TileIndex tile2, uint h, DoCommandFlag flags, Money & money, CommandCost & cost)
+{
+	uint curh = TileHeight(tile2);
+	while (curh != h) {
+		CommandCost ret = DoCommand(tile2, SLOPE_N, (curh > h) ? 0 : 1,
+			flags & ~DC_EXEC, CMD_TERRAFORM_LAND);
+		if (CmdFailed(ret)) break;
+
+		if (flags & DC_EXEC) {
+			money -= ret.GetCost();
+			if (money < 0) {
+				_additional_cash_required = ret.GetCost();
+				return false;
+			}
+			DoCommand(tile2, SLOPE_N, (curh > h) ? 0 : 1, flags,
+				CMD_TERRAFORM_LAND);
+		}
+
+		cost.AddCost(ret);
+		curh += (curh > h) ? -1 : 1;
+	}
+	return true;
+}
 
 /** Levels a selected (rectangle) area of land
  * @param tile end tile of area-drag
  * @param flags for this command type
  * @param p1 start tile of area drag
- * @param p2 height difference; eg raise (+1), lower (-1) or level (0)
+ * @param p2 see @LevelMode and @Orientation; flags for the mode of levelling (up, down, diagonal ...)
  * @return  error or cost of terraforming
  */
 CommandCost CmdLevelLand(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
@@ -364,46 +387,27 @@
 	uint oldh = TileHeight(p1);
 
 	/* compute new height */
-	uint h = oldh + p2;
+	uint h = oldh;
+	if (p2 & LEVEL_RAISE) h++;
+	if (p2 & LEVEL_LOWER) h--;
 
 	/* Check range of destination height */
 	if (h > MAX_TILE_HEIGHT) return_cmd_error((oldh == 0) ? STR_1003_ALREADY_AT_SEA_LEVEL : STR_1004_TOO_HIGH);
 	if (p2 == 0) _error_message = STR_ALREADY_LEVELLED;
 
-	/* make sure sx,sy are smaller than ex,ey */
-	int ex = TileX(tile);
-	int ey = TileY(tile);
-	int sx = TileX(p1);
-	int sy = TileY(p1);
-	if (ex < sx) Swap(ex, sx);
-	if (ey < sy) Swap(ey, sy);
-	tile = TileXY(sx, sy);
-
-	int size_x = ex - sx + 1;
-	int size_y = ey - sy + 1;
-
 	Money money = GetAvailableMoneyForCommand();
 	CommandCost cost(EXPENSES_CONSTRUCTION);
 
-	BEGIN_TILE_LOOP(tile2, size_x, size_y, tile) {
-		uint curh = TileHeight(tile2);
-		while (curh != h) {
-			CommandCost ret = DoCommand(tile2, SLOPE_N, (curh > h) ? 0 : 1, flags & ~DC_EXEC, CMD_TERRAFORM_LAND);
-			if (CmdFailed(ret)) break;
-
-			if (flags & DC_EXEC) {
-				money -= ret.GetCost();
-				if (money < 0) {
-					_additional_cash_required = ret.GetCost();
-					return cost;
-				}
-				DoCommand(tile2, SLOPE_N, (curh > h) ? 0 : 1, flags, CMD_TERRAFORM_LAND);
-			}
-
-			cost.AddCost(ret);
-			curh += (curh > h) ? -1 : 1;
+	if (p2 & ORIENTATION_DIAG) {
+		for (DiagIterator iter(tile, p1); iter != TileIterator::end; ++iter) {
+			if (!LevelSingleTile(*iter, h, flags, money, cost)) return cost;
 		}
-	} END_TILE_LOOP(tile2, size_x, size_y, tile)
+	}
+	if (p2 & ORIENTATION_ORTH){
+		for (OrthIterator iter(tile, p1); iter != TileIterator::end; ++iter) {
+			if (!LevelSingleTile(*iter, h, flags, money, cost)) return cost;
+		}
+	}
 
 	return (cost.GetCost() == 0) ? CMD_ERROR : cost;
 }
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/terraform_gui.cpp
--- src/terraform_gui.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/terraform_gui.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -121,16 +121,16 @@
 
 	switch (proc) {
 		case DDSP_DEMOLISH_AREA:
-			DoCommandP(end_tile, start_tile, 0, CMD_CLEAR_AREA | CMD_MSG(STR_00B5_CAN_T_CLEAR_THIS_AREA), CcPlaySound10);
+			DoCommandP(end_tile, start_tile, _ctrl_pressed ? ORIENTATION_DIAG : ORIENTATION_ORTH, CMD_CLEAR_AREA | CMD_MSG(STR_00B5_CAN_T_CLEAR_THIS_AREA), CcPlaySound10);
 			break;
 		case DDSP_RAISE_AND_LEVEL_AREA:
-			DoCommandP(end_tile, start_tile, 1, CMD_LEVEL_LAND | CMD_MSG(STR_0808_CAN_T_RAISE_LAND_HERE), CcTerraform);
+			DoCommandP(end_tile, start_tile, LEVEL_RAISE | ORIENTATION_ORTH, CMD_LEVEL_LAND | CMD_MSG(STR_0808_CAN_T_RAISE_LAND_HERE), CcTerraform);
 			break;
 		case DDSP_LOWER_AND_LEVEL_AREA:
-			DoCommandP(end_tile, start_tile, (uint32)-1, CMD_LEVEL_LAND | CMD_MSG(STR_0809_CAN_T_LOWER_LAND_HERE), CcTerraform);
+			DoCommandP(end_tile, start_tile, LEVEL_LOWER | ORIENTATION_ORTH, CMD_LEVEL_LAND | CMD_MSG(STR_0809_CAN_T_LOWER_LAND_HERE), CcTerraform);
 			break;
 		case DDSP_LEVEL_AREA:
-			DoCommandP(end_tile, start_tile, 0, CMD_LEVEL_LAND | CMD_MSG(STR_CAN_T_LEVEL_LAND_HERE), CcTerraform);
+			DoCommandP(end_tile, start_tile, _ctrl_pressed ? ORIENTATION_DIAG : ORIENTATION_ORTH, CMD_LEVEL_LAND, CcPlaySound10);
 			break;
 		case DDSP_CREATE_ROCKS:
 			GenerateRockyArea(end_tile, start_tile);
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/tilehighlight_type.h
--- src/tilehighlight_type.h	Sun Apr 12 15:17:27 2009 +0000
+++ src/tilehighlight_type.h	Sun Apr 12 18:10:09 2009 +0200
@@ -72,6 +72,8 @@
 	ViewportDragDropSelectionProcess select_proc;
 
 	TileIndex redsq;
+	bool diagonal;     ///< true if dragging a 45 degrees rotated rectangle
+	bool new_diagonal;
 };
 
 #endif /* TILEHIGHLIGHT_TYPE_H */
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/toolbar_gui.cpp
--- src/toolbar_gui.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/toolbar_gui.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -1090,6 +1090,7 @@
 			case WKC_CTRL  | 'S': MenuClickSmallScreenshot(); break;
 			case WKC_CTRL  | 'G': MenuClickWorldScreenshot(); break;
 			case WKC_CTRL | WKC_ALT | 'C': if (!_networking) ShowCheatWindow(); break;
+			case WKC_CTRL | 'L': ShowSignList(); break;
 			case 'A': if (CanBuildVehicleInfrastructure(VEH_TRAIN)) ShowBuildRailToolbar(_last_built_railtype, 4); break; // Invoke Autorail
 			case 'L': ShowTerraformToolbar(); break;
 			case 'M': ShowSmallMap(); break;
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/town.h
--- src/town.h	Sun Apr 12 15:17:27 2009 +0000
+++ src/town.h	Sun Apr 12 18:10:09 2009 +0200
@@ -251,6 +251,7 @@
 uint32 GetWorldPopulation();
 
 void UpdateTownVirtCoord(Town *t);
+uint16 TownSignColour(Town *t);
 void UpdateAllTownVirtCoords();
 void InitializeTown();
 void ShowTownViewWindow(TownID town);
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/town_cmd.cpp
--- src/town_cmd.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/town_cmd.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -316,6 +316,34 @@
 }
 
 /**
+ * Finds the required colour of the town sign based in the rating
+ * @param t Town that we need the colour for
+ */
+uint16 TownSignColour(Town *t)
+{
+	if((_game_mode == GM_EDITOR) || (!_settings_client.gui.rating_in_label) || (_current_company == COMPANY_SPECTATOR)) return TC_WHITE;
+
+	uint16 colour;
+
+	int r = t->ratings[_current_company];
+	
+	if(r <= RATING_VERYPOOR){
+		colour = TC_RED;
+	}
+	else if(r <= RATING_MEDIOCRE){
+		colour = TC_YELLOW;
+	}
+	else if(r <= RATING_VERYGOOD){
+		colour = TC_WHITE;
+	}
+	else{
+		colour = TC_GREEN;
+	}
+
+	return colour;
+}
+
+/**
  * Resize the sign(label) of the town after changes in
  * population (creation or growth or else)
  * @param t Town to update
@@ -2341,6 +2369,7 @@
 		 */
 		if (t->ratings[_current_company] > RATING_BRIBE_DOWN_TO) {
 			t->ratings[_current_company] = RATING_BRIBE_DOWN_TO;
+			UpdateTownVirtCoord(t);
 			InvalidateWindow(WC_TOWN_AUTHORITY, t->index);
 		}
 	} else {
@@ -2452,7 +2481,7 @@
 	return cost;
 }
 
-static void UpdateTownGrowRate(Town *t)
+void UpdateTownGrowRate(Town *t)
 {
 	/* Increase company ratings if they're low */
 	const Company *c;
@@ -2690,6 +2719,7 @@
 	} else {
 		SetBit(t->have_ratings, _current_company);
 		t->ratings[_current_company] = rating;
+		UpdateTownVirtCoord(t);
 		InvalidateWindow(WC_TOWN_AUTHORITY, t->index);
 	}
 }
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/town_gui.cpp
--- src/town_gui.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/town_gui.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -93,6 +93,25 @@
 
 	virtual void OnPaint()
 	{
+		int16 oldrat[MAX_COMPANIES], newrat[MAX_COMPANIES];
+		assert(sizeof(oldrat) == sizeof(this->town->ratings) && sizeof(newrat) == sizeof(this->town->ratings));
+		memcpy(oldrat, this->town->ratings, sizeof(this->town->ratings));
+		int32 oldgrow = _settings_game.economy.town_growth_rate;
+		byte oldmonths = this->town->fund_buildings_months;
+		_settings_game.economy.town_growth_rate = 0;
+		this->town->fund_buildings_months = 0;
+		byte oldflags = this->town->flags12;
+
+		extern void UpdateTownGrowRate(Town *t);
+		UpdateTownGrowRate(this->town);
+
+		memcpy(newrat, this->town->ratings, sizeof(this->town->ratings));
+
+		memcpy(this->town->ratings, oldrat, sizeof(this->town->ratings));
+		_settings_game.economy.town_growth_rate = oldgrow;
+		this->town->fund_buildings_months = oldmonths;
+		this->town->flags12 = oldflags;
+
 		int numact;
 		uint buttons = GetMaskOfTownActions(&numact, _local_company, this->town);
 
@@ -138,6 +157,12 @@
 				}
 
 				DrawString(this->widget[TWA_RATING_INFO].left + 28, this->widget[TWA_RATING_INFO].right - 2, y, STR_2024, TC_FROMSTRING);
+
+				SetDParam(0, this->town->ratings[c->index]);
+				DrawString(this->widget[TWA_RATING_INFO].right - 70, this->widget[TWA_RATING_INFO].right - 35, y, STR_JUST_INT, TC_YELLOW);
+				SetDParam(0, newrat[c->index] - this->town->ratings[c->index]);
+				DrawString(this->widget[TWA_RATING_INFO].right - 35, this->widget[TWA_RATING_INFO].right, y, STR_JUST_INT, TC_YELLOW);
+
 				y += 10;
 			}
 		}
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/vehicle.cpp
--- src/vehicle.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/vehicle.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -224,7 +224,7 @@
 
 /* Size of the hash, 6 = 64 x 64, 7 = 128 x 128. Larger sizes will (in theory) reduce hash
  * lookup times at the expense of memory usage. */
-const int HASH_BITS = 7;
+const int HASH_BITS = 9;
 const int HASH_SIZE = 1 << HASH_BITS;
 const int HASH_MASK = HASH_SIZE - 1;
 const int TOTAL_HASH_SIZE = 1 << (HASH_BITS * 2);
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/viewport.cpp
--- src/viewport.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/viewport.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -43,6 +43,8 @@
 #include "table/sprites.h"
 #include "table/strings.h"
 
+static const int VIEWPORT_DRAW_MEM = 65536 * 32;
+
 PlaceProc *_place_proc;
 Point _tile_fract_coords;
 ZoomLevel _saved_scrollpos_zoom;
@@ -691,6 +693,17 @@
 	_vd.combine_sprites = 0;
 }
 
+bool IsInsideRotatedRectangle(int x, int y)
+{
+	int dist_a = (_thd.size.x + _thd.size.y); // Rotated coordinate system for selected rectangle
+	int dist_b = (_thd.size.x - _thd.size.y); // We don't have to divide by 2. It's all relative!
+	int a = ((x - _thd.pos.x) + (y - _thd.pos.y)); // Rotated coordinate system for the point under scrutiny
+	int b = ((x - _thd.pos.x) - (y - _thd.pos.y));
+
+	return ((dist_a >= 0 && a <= dist_a && a >= 0) || (dist_a < 0 && a >= dist_a && a <= 0)) &&
+			((dist_b >= 0 && b <= dist_b && b >= 0) || (dist_b < 0 && b >= dist_b && b <= 0));
+}
+
 /**
  * Add a child sprite to a parent sprite.
  *
@@ -878,6 +891,26 @@
 	/* no selection active? */
 	if (_thd.drawstyle == 0) return;
 
+	if (_thd.diagonal) { // We're drawing a 45 degrees rotated (diagonal) rectangle
+		if (IsInsideRotatedRectangle((int)ti->x, (int)ti->y)) {
+			if (_thd.drawstyle & HT_RECT) { // highlighting a square (clear land)
+				SpriteID image = SPR_SELECT_TILE + _tileh_to_sprite[ti->tileh];
+				DrawSelectionSprite(image, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE, ti, 7, FOUNDATION_PART_NORMAL);
+			} else { // highlighting a dot (level land)
+				/* Figure out the Z coordinate for the single dot. */
+				byte z = ti->z;
+				if (ti->tileh & 8) {
+					z += 8;
+					if (!(ti->tileh & 2) && (ti->tileh & 0x10)) {
+						z += 8;
+					}
+				}
+				DrawGroundSpriteAt(_cur_dpi->zoom != 2 ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti->x, ti->y, z);
+			}
+		}
+		return;
+	}
+
 	/* Inside the inner area? */
 	if (IsInsideBS(ti->x, _thd.pos.x, _thd.size.x) &&
 			IsInsideBS(ti->y, _thd.pos.y, _thd.size.y)) {
@@ -1043,7 +1076,7 @@
 						left   < t->sign.left + t->sign.width_1) {
 					AddStringToDraw(t->sign.left + 1, t->sign.top + 1,
 						_settings_client.gui.population_in_label ? STR_TOWN_LABEL_POP : STR_TOWN_LABEL,
-						t->index, t->population);
+						t->index, t->population, TownSignColour(t));
 				}
 			}
 			break;
@@ -1059,7 +1092,7 @@
 						left   < t->sign.left + t->sign.width_1 * 2) {
 					AddStringToDraw(t->sign.left + 1, t->sign.top + 1,
 						_settings_client.gui.population_in_label ? STR_TOWN_LABEL_POP : STR_TOWN_LABEL,
-						t->index, t->population);
+						t->index, t->population, TownSignColour(t));
 				}
 			}
 			break;
@@ -1454,6 +1487,9 @@
 			/* Real colours need the IS_PALETTE_COLOUR flag
 			 * otherwise colours from _string_colourmap are assumed. */
 			colour = (TextColour)_colour_gradient[ss->colour][6] | IS_PALETTE_COLOUR;
+		} else if(ss->string != STR_2806 && ss->width == 0) {
+			/* Colours for town signs */
+			colour = (TextColour)ss->colour;
 		} else {
 			colour = TC_BLACK;
 		}
@@ -1532,7 +1568,7 @@
  * If we do, the sprite memory will overflow. */
 static void ViewportDrawChk(const ViewPort *vp, int left, int top, int right, int bottom)
 {
-	if (ScaleByZoom(bottom - top, vp->zoom) * ScaleByZoom(right - left, vp->zoom) > 180000) {
+	if (ScaleByZoom(bottom - top, vp->zoom) * ScaleByZoom(right - left, vp->zoom) > VIEWPORT_DRAW_MEM) {
 		if ((bottom - top) > (right - left)) {
 			int t = (top + bottom) >> 1;
 			ViewportDrawChk(vp, left, top, right, t);
@@ -1744,26 +1780,41 @@
 	x_size = _thd.size.x;
 	y_size = _thd.size.y;
 
-	if (_thd.outersize.x) {
-		x_size += _thd.outersize.x;
-		x += _thd.offs.x;
-		y_size += _thd.outersize.y;
-		y += _thd.offs.y;
+	if (!_thd.diagonal) { // Selecting in a straigth rectangle (or a single square)
+		if (_thd.outersize.x) {
+			x_size += _thd.outersize.x;
+			x += _thd.offs.x;
+			y_size += _thd.outersize.y;
+			y += _thd.offs.y;
+		}
+		assert(x_size > 0);
+		assert(y_size > 0);
+
+		x_size += x;
+		y_size += y;
+
+		do {
+			int y_bk = y;
+			do {
+				MarkTileDirty(x, y);
+			} while ((y += TILE_SIZE) != y_size);
+			y = y_bk;
+		} while ((x += TILE_SIZE) != x_size);
+	} else { // Selecting in a 45 degrees rotated (diagonal) rectangle.
+		/* a_size, b_size describe a rectangle with rotated coordinates */
+		int a_size = x_size + y_size, b_size = x_size - y_size;
+
+		int interval_a = a_size < 0 ? -TILE_SIZE : TILE_SIZE;
+		int interval_b = b_size < 0 ? -TILE_SIZE : TILE_SIZE;
+
+		for (int a = -interval_a; a != a_size + interval_a; a += interval_a) {
+			for (int b = -interval_b; b != b_size + interval_b; b += interval_b) {
+				x = _thd.pos.x + (a + b) / 2;
+				y = _thd.pos.y + (a - b) / 2;
+				MarkTileDirty(x, y);
+			}
+		}
 	}
-
-	assert(x_size > 0);
-	assert(y_size > 0);
-
-	x_size += x;
-	y_size += y;
-
-	do {
-		int y_bk = y;
-		do {
-			MarkTileDirty(x, y);
-		} while ( (y += TILE_SIZE) != y_size);
-		y = y_bk;
-	} while ( (x += TILE_SIZE) != x_size);
 }
 
 
@@ -2135,6 +2186,12 @@
 	return HT_RAIL | _autorail_piece[x & 0xF][y & 0xF];
 }
 
+static inline bool DraggingDiagonal()
+{
+	return _ctrl_pressed && _thd.select_method == VPM_X_AND_Y &&
+		(_thd.select_proc == DDSP_DEMOLISH_AREA || _thd.select_proc == DDSP_LEVEL_AREA);
+}
+
 /**
  * Updates tile highlighting for all cases.
  * Uses _thd.selstart and _thd.selend and _thd.place_mode (set elsewhere) to determine _thd.pos and _thd.size
@@ -2148,6 +2205,7 @@
 	int y1;
 
 	_thd.new_drawstyle = 0;
+	_thd.new_diagonal = false;
 
 	if (_thd.place_mode == VHM_SPECIAL) {
 		x1 = _thd.selend.x;
@@ -2158,12 +2216,20 @@
 			x1 &= ~0xF;
 			y1 &= ~0xF;
 
-			if (x1 >= x2) Swap(x1, x2);
-			if (y1 >= y2) Swap(y1, y2);
+			if ( DraggingDiagonal() )
+				_thd.new_diagonal = true;
+			else {
+				if (x1 >= x2) Swap(x1,x2);
+				if (y1 >= y2) Swap(y1,y2);
+			}
 			_thd.new_pos.x = x1;
 			_thd.new_pos.y = y1;
-			_thd.new_size.x = x2 - x1 + TILE_SIZE;
-			_thd.new_size.y = y2 - y1 + TILE_SIZE;
+			_thd.new_size.x = x2 - x1;
+			_thd.new_size.y = y2 - y1;
+			if (!_thd.new_diagonal) {
+				_thd.new_size.x += TILE_SIZE;
+				_thd.new_size.y += TILE_SIZE;
+			}
 			_thd.new_drawstyle = _thd.next_drawstyle;
 		}
 	} else if (_thd.place_mode != VHM_NONE) {
@@ -2197,7 +2263,8 @@
 			_thd.pos.x != _thd.new_pos.x || _thd.pos.y != _thd.new_pos.y ||
 			_thd.size.x != _thd.new_size.x || _thd.size.y != _thd.new_size.y ||
 			_thd.outersize.x != _thd.new_outersize.x ||
-			_thd.outersize.y != _thd.new_outersize.y) {
+			_thd.outersize.y != _thd.new_outersize.y ||
+			_thd.diagonal    != _thd.new_diagonal) {
 		/* clear the old selection? */
 		if (_thd.drawstyle) SetSelectionTilesDirty();
 
@@ -2205,6 +2272,7 @@
 		_thd.pos = _thd.new_pos;
 		_thd.size = _thd.new_size;
 		_thd.outersize = _thd.new_outersize;
+		_thd.diagonal = _thd.new_diagonal;
 		_thd.dirty = 0xff;
 
 		/* draw the new selection? */
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/window.cpp
--- src/window.cpp	Sun Apr 12 15:17:27 2009 +0000
+++ src/window.cpp	Sun Apr 12 18:10:09 2009 +0200
@@ -1304,7 +1304,6 @@
 static bool HandleDragDrop()
 {
 	if (_special_mouse_mode != WSM_DRAGDROP) return true;
-	if (_left_button_down) return false;
 
 	Window *w = GetCallbackWnd();
 
@@ -1313,7 +1312,13 @@
 		Point pt;
 		pt.x = _cursor.pos.x - w->left;
 		pt.y = _cursor.pos.y - w->top;
-		w->OnDragDrop(pt, GetWidgetFromPos(w, pt.x, pt.y));
+
+		if (_left_button_down) {
+			w->OnDragMove(pt, GetWidgetFromPos(w, pt.x, pt.y));
+			return false;
+		} else {
+			w->OnDragDrop(pt, GetWidgetFromPos(w, pt.x, pt.y));
+		}
 	}
 
 	ResetObjectToPlace();
diff -r 76fc4bf1ce4b -r 9e821d4b10b8 src/window_gui.h
--- src/window_gui.h	Sun Apr 12 15:17:27 2009 +0000
+++ src/window_gui.h	Sun Apr 12 18:10:09 2009 +0200
@@ -455,6 +455,13 @@
 	virtual void OnDragDrop(Point pt, int widget) {}
 
 	/**
+	 * An 'object' is being dragged.
+	 * @param pt     the point inside the window where the cursor points to.
+	 * @param widget the widget where the cursor points to.
+	 */
+	virtual void OnDragMove(Point pt, int widget) {}
+
+	/**
 	 * Handle the request for (viewport) scrolling.
 	 * @param delta the amount the viewport must be scrolled.
 	 */
